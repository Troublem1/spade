1
00:00:00.126 --> 00:00:04.170
音楽

2
00:00:04.170 --> 00:00:08.961
これまでのビデオでは、平均符号化がそのま
ま使用できないことを認識し、

3
00:00:08.961 --> 00:00:13.970
データの一部をトレーニングに正規化する必
要があります。

4
00:00:13.970 --> 00:00:18.980
さて、我々は、正規化の4つの異なる方法を
実行します、すなわち、

5
00:00:18.980 --> 00:00:24.070
クロス検証ループを実行して、平均エンコー
ディングを構築します。

6
00:00:24.070 --> 00:00:27.910
次に、カテゴリのサイズに基づいてスムージ
ングします。

7
00:00:27.910 --> 00:00:30.650
次に、ランダムノイズを追加します。

8
00:00:30.650 --> 00:00:36.120
そして最後に、データのいくつかのパラメト
リゼーションの拡大の平均を計算する。

9
00:00:36.120 --> 00:00:39.100
私たちは、これらすべての方法を一つ一つ行
っていきます。

10
00:00:40.380 --> 00:00:43.570
CV ループ正則化から始めましょう。

11
00:00:43.570 --> 00:00:46.430
これは非常に直感的で堅牢な方法です。

12
00:00:46.430 --> 00:00:51.780
特定のデータポイントについては、そのデー
タポイントのターゲット変数を使用する必要
はありません。

13
00:00:51.780 --> 00:00:57.040
そこで、データを K
ノードの交差するサブセットに分割し、

14
00:00:57.040 --> 00:00:59.390
または言い換えれば、襞。

15
00:00:59.390 --> 00:01:04.750
一部のサブセットの平均エンコード値を取得
するには、データポイントを使用しません。

16
00:01:04.750 --> 00:01:10.210
そのサブセットから、サブセットの残りの部
分でのみエンコーディングを推定します。

17
00:01:11.650 --> 00:01:14.530
我々は、すべてのデータのサブセットを繰り
返し歩く。

18
00:01:15.750 --> 00:01:19.550
通常、4つまたは5つの襞は、まともな結果
を得るために十分です。

19
00:01:19.550 --> 00:01:21.250
この番号を調整する必要はありません。

20
00:01:22.320 --> 00:01:27.910
我々は完全にターゲット変数からのリークを
避けているように見えるかもしれません。

21
00:01:27.910 --> 00:01:29.670
残念ながら、それは真実ではない。

22
00:01:31.040 --> 00:01:36.270
我々はデータを分離するために1つのアウト
スキームを残す実行する場合、それは明らか
になるだろう。

23
00:01:36.270 --> 00:01:38.576
あと少ししたらそれに戻りますが、

24
00:01:38.576 --> 00:01:42.642
しかし、まずこの方法を実際に適用する方法
を学びましょう。

25
00:01:42.642 --> 00:01:49.820
トレーニングデータが DFTR
データフレームにあると仮定します。

26
00:01:51.150 --> 00:01:55.570
我々は別の列車の新しいデータフレームに平
均符号化機能を追加します。

27
00:01:56.990 --> 00:02:02.330
外側のループでは、我々は、層状 K
倍を繰り返し

28
00:02:02.330 --> 00:02:06.345
反復子は、チャンクにトレーニングデータを
分離するために。

29
00:02:06.345 --> 00:02:09.905
X_tr は、エンコーディングを推定する
ために使用されます。

30
00:02:09.905 --> 00:02:12.940
X_val は、エンコードの推定を適用す
るために使用します。

31
00:02:14.020 --> 00:02:18.471
その後、すべての列を反復処理し、

32
00:02:18.471 --> 00:02:22.630
推定エンコーディングを X_val
データフレームにマップします。

33
00:02:22.630 --> 00:02:27.820
外側のループの終わりに我々は結果との列車
の新しいデータフレームを埋める。

34
00:02:27.820 --> 00:02:33.170
最後に、いくつかのまれなカテゴリにのみ1
つ折りに存在することがあります。

35
00:02:33.170 --> 00:02:37.330
したがって、ターゲットの平均値を見積もる
ためのデータはありません。

36
00:02:37.330 --> 00:02:40.840
だから私たちはいくつかの nans
で終わる。

37
00:02:40.840 --> 00:02:42.620
我々は、グローバルな意味でそれらを埋める
ことができます。

38
00:02:43.900 --> 00:02:46.770
あなたが見ることができるように、全体のプ
ロセスは非常に簡単です。

39
00:02:47.900 --> 00:02:51.940
さて、どうかという問いに戻りましょう

40
00:02:51.940 --> 00:02:56.290
ターゲット変数に関する情報をリークします
。

41
00:02:56.290 --> 00:02:57.770
次の例を考えてみましょう。

42
00:02:58.860 --> 00:03:02.350
ここでは、モスクワを残して1つのスキーム
を介してエンコードします。

43
00:03:03.440 --> 00:03:07.872
最初の行については、我々は2つの1s
があるため、0.5 を取得し、

44
00:03:07.872 --> 00:03:10.310
残りの行には2つの0s があります。

45
00:03:10.310 --> 00:03:16.540
同様に、2番目の行のために我々は0.25
を取得します。

46
00:03:16.540 --> 00:03:21.060
しかし、よく見て、すべての結果と結果の機
能。

47
00:03:21.060 --> 00:03:25.664
それは完全にデータを分割する,
機能を持つ行は等しいまたは平均

48
00:03:25.664 --> 00:03:31.980
0.5 より大きい値はターゲット0を持ち
、残りの行にはターゲット1があります。

49
00:03:31.980 --> 00:03:38.040
ターゲット変数を明示的に使用しませんでし
たが、エンコードは偏っています。

50
00:03:38.040 --> 00:03:43.700
さらに, この効果は、KFold
スキームのためにも有効なまま,
ちょうど穏やか.

51
00:03:45.030 --> 00:03:47.729
だからこのタイプの正則化は無用ですか?

52
00:03:48.800 --> 00:03:50.200
絶対にありません。

53
00:03:50.200 --> 00:03:53.340
実際には、十分なデータがあり、4つまたは
使用する場合

54
00:03:53.340 --> 00:03:58.660
5つ折り、符号化はこの正則化戦略でうまく
動作します。

55
00:03:58.660 --> 00:04:01.080
ただ注意して、正しい検証を使用してくださ
い。

56
00:04:02.210 --> 00:04:05.390
もう1つの正規化方法はスムージングです。

57
00:04:05.390 --> 00:04:07.750
これは、次のアイデアに基づいています。

58
00:04:07.750 --> 00:04:13.340
カテゴリが大きい場合は、多くのデータポイ
ントを持っているし、我々はすることができ
ます

59
00:04:13.340 --> 00:04:19.295
[聞き取れない] エンコードにこれを信頼
しますが、カテゴリがまれであれば逆です。

60
00:04:19.295 --> 00:04:22.450
スライドの数式は、このアイデアを使用しま
す。

61
00:04:22.450 --> 00:04:27.170
正規化の量を制御するハイパーパラメーター
アルファがあります。

62
00:04:27.170 --> 00:04:31.280
アルファがゼロの場合、正規化は行われず、

63
00:04:31.280 --> 00:04:35.370
アルファが無限に近づくと、すべてが
globalmean に変わります。

64
00:04:36.520 --> 00:04:42.240
いくつかの意味でアルファは、我々が信頼で
きるカテゴリのサイズに等しくなります。

65
00:04:42.240 --> 00:04:47.250
また、いくつかの他の数式を使用することが
可能です, 基本的には何も罰する

66
00:04:47.250 --> 00:04:51.360
エンコードソフトウェアのカテゴリはスムー
ジングと見なすことができます。

67
00:04:51.360 --> 00:04:54.520
スムージングは、明らかに独自に動作しませ
んが、

68
00:04:54.520 --> 00:04:59.250
私たちは、例えば、CD ループ正則化と組
み合わせることができます。

69
00:04:59.250 --> 00:05:05.880
encodence を定例化するもう1つ
の方法は、正規化せずにノイズを追加するこ
とです。

70
00:05:05.880 --> 00:05:07.930
意味コーディングのためのより良い品質を持
っている

71
00:05:07.930 --> 00:05:11.040
テストデータよりも [聞き取れない]
データ。

72
00:05:11.040 --> 00:05:15.970
また、ノイズを追加することで、トレーニン
グデータのエンコードの品質を低下させるだ
けです。

73
00:05:17.080 --> 00:05:21.460
この方法はかなり不安定で、それを動作させ
るのは難しい。

74
00:05:21.460 --> 00:05:25.135
主な問題は、我々が追加する必要があるノイ
ズの量です。

75
00:05:25.135 --> 00:05:28.876
あまりにも多くのノイズは、ゴミに機能を有
効にします

76
00:05:28.876 --> 00:05:32.800
あまりにも少ないノイズは、より悪い正則化
を意味します。

77
00:05:33.900 --> 00:05:38.940
このメソッドは、通常、1つの out
正規化と共に使用されます。

78
00:05:38.940 --> 00:05:41.340
あなたが熱心に微調整する必要があります。

79
00:05:42.370 --> 00:05:46.650
だから、それはおそらくあなたが多くの時間
を持っていない場合、最良の選択肢ではない
。

80
00:05:47.830 --> 00:05:53.330
私はカバーするつもりだ最後の正則化の方法
は、拡大の平均に基づいています。

81
00:05:53.330 --> 00:05:54.840
アイデアは非常に簡単です。

82
00:05:55.850 --> 00:05:59.310
我々は、データのいくつかの並べ替え順序を
修正し、

83
00:05:59.310 --> 00:06:05.160
行 n
のエンコードを計算するには、0から n
を引いた行のみを使用します。

84
00:06:06.600 --> 00:06:10.070
コードスニペットで簡単な実装を確認できま
す。

85
00:06:11.530 --> 00:06:16.230
Cumsum
はターゲット変数の累積合計を格納します。

86
00:06:16.230 --> 00:06:20.185
指定された行と cumcnt
は累積数を格納します。

87
00:06:21.270 --> 00:06:25.604
この方法は、ターゲット変数からのリークの
最小量を導入し、

88
00:06:25.604 --> 00:06:28.483
ハイパーパラメータのチューニングは必要あ
りません。

89
00:06:28.483 --> 00:06:31.920
唯一の欠点は、機能の品質が均一ではないと
いうことです。

90
00:06:33.320 --> 00:06:34.430
しかし、それは大したことではありません。

91
00:06:34.430 --> 00:06:37.090
我々はモデルを平均することができます

92
00:06:37.090 --> 00:06:40.940
異なるデータ順列から計算された符号化につ
いて。

93
00:06:42.180 --> 00:06:46.290
また、それは平均法を拡大している注目に値
する

94
00:06:46.290 --> 00:06:50.800
それは CatBoost の等級で使用さ
れ、それの図書館に後押しする、

95
00:06:50.800 --> 00:06:55.609
これは、カテゴリの機能を持つデータセット
で見事に実行することを証明する。

96
00:06:56.660 --> 00:07:00.910
さて、このビデオで説明したことを要約して
みましょう。

97
00:07:00.910 --> 00:07:03.880
4種類の正則化について説明した。

98
00:07:04.980 --> 00:07:09.900
それぞれの長所と短所があります。

99
00:07:09.900 --> 00:07:13.870
時には unintuitively
ターゲット変数のリークを紹介します。

100
00:07:13.870 --> 00:07:17.090
しかし、実際には、我々はそれに耐えること
ができます。

101
00:07:17.090 --> 00:07:21.240
個人的に、私は CV
ループまたは拡大の平均方法をお勧めします

102
00:07:21.240 --> 00:07:22.920
実用的なタスク。

103
00:07:22.920 --> 00:07:24.976
彼らは、最も堅牢で調整が容易です。

104
00:07:24.976 --> 00:07:28.210
これは、正規化されました。

105
00:07:28.210 --> 00:07:32.270
次のビデオでは、私は様々な拡張機能につい
て教えてくれます

106
00:07:32.270 --> 00:07:35.700
平均符号化の実用的な適用。

107
00:07:35.700 --> 00:07:38.002
ありがとう。

108
00:07:38.002 --> 00:07:48.002
音楽

