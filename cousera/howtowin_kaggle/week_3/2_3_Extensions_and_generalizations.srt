1
00:00:02.016 --> 00:00:07.827
音最後のビデオでは、我々は様々な一般化を
カバーし、

2
00:00:07.827 --> 00:00:10.544
平均符号化の拡張。

3
00:00:10.544 --> 00:00:15.250
すなわちどのように回帰と
multiclass
のタスクでコーディングを意味する。

4
00:00:16.600 --> 00:00:20.409
多 ~ 多のリレーションを持つドメインに
エンコーディングを適用する方法について説
明します。

5
00:00:21.640 --> 00:00:26.070
我々は時系列でできるようにしているターゲ
ットに基づいてどのような機能を構築するこ
とができます。

6
00:00:26.070 --> 00:00:30.770
そして最後に、どのように機能の数値機能と
の相互作用をエンコードする。

7
00:00:31.790 --> 00:00:34.275
まず、回帰タスクから始めましょう。

8
00:00:34.275 --> 00:00:38.405
これらは、実際には機能のエンコーディング
に柔軟性があります。

9
00:00:38.405 --> 00:00:42.945
バイナリの分類とは異なり、ここでは、率直
に意味のある唯一の意味

10
00:00:42.945 --> 00:00:46.095
我々は、ターゲット変数から抽出することが
できます統計。

11
00:00:46.095 --> 00:00:51.365
回帰タスクでは、メディアのようにさまざま
な統計を試すことができます。

12
00:00:51.365 --> 00:00:55.240
パーセンタイル、ターゲット変数の標準偏差
。

13
00:00:55.240 --> 00:00:58.770
私たちもいくつかの配布ビンを計算すること
ができます。

14
00:00:58.770 --> 00:01:03.620
たとえば、ターゲット変数が 1 ~
100 の間で分散されている場合、

15
00:01:03.620 --> 00:01:07.410
私達は10の大箱の特徴を作成できる。

16
00:01:07.410 --> 00:01:13.755
最初の機能では、1からターゲットを絞った
データ・ポイントの数をカウントします。

17
00:01:13.755 --> 00:01:17.830
10、10と20の間に2番目のように。

18
00:01:19.180 --> 00:01:22.500
もちろん、これらすべての機能を実現する必
要があります。

19
00:01:23.640 --> 00:01:28.390
簡単に言えば、回帰タスクは分類のようなも
のです。

20
00:01:28.390 --> 00:01:31.310
特徴工学の面でちょうどより適用範囲が広い
。

21
00:01:32.500 --> 00:01:37.410
マルチクラスのタスクをエンコードする男性
もかなり簡単です。

22
00:01:37.410 --> 00:01:39.090
エンコードしたいすべての機能について、

23
00:01:39.090 --> 00:01:45.360
n がクラスの数である場合には、異なるエ
ンコーディングがあります。

24
00:01:45.360 --> 00:01:48.520
それは実際に非明白な利点を有する。

25
00:01:48.520 --> 00:01:49.320
3つのモデル

26
00:01:49.320 --> 00:01:54.640
例では、通常1対古い方法でマルチクラスの
タスクを解決します。

27
00:01:54.640 --> 00:01:58.260
すべてのクラスが異なるモデルを持っていた
ので、

28
00:01:58.260 --> 00:02:03.190
我々はそのモデルを養うとき、それは構造に
ついての情報を持っていません

29
00:02:03.190 --> 00:02:07.760
他のクラスの1つのエンティティにマージさ
れるため。

30
00:02:08.780 --> 00:02:11.676
したがって、平均符号化とともに、

31
00:02:11.676 --> 00:02:16.945
他のクラスの構造についての追加情報を紹介
します。

32
00:02:16.945 --> 00:02:21.581
多 ~ 多の関係を持つドメインは、通常、
非常に複雑であり、

33
00:02:21.581 --> 00:02:26.030
平均エンコーディングを作成するには特別な
方法が必要です。

34
00:02:26.030 --> 00:02:30.760
私はあなたの例を考慮し、非常に高いレベル
のアイデアを提供します。

35
00:02:30.760 --> 00:02:36.895
スマートフォンにインストールされているア
プリに基づくユーザーのためのバイナリ分類
タスク。

36
00:02:37.970 --> 00:02:44.480
各ユーザーは複数のアプリを持つことができ
、各アプリは複数のユーザーによって使用さ
れます。

37
00:02:44.480 --> 00:02:46.030
したがって、多 ~ 多の関係。

38
00:02:47.310 --> 00:02:49.960
我々は、アプリをエンコードすることを意味
します。

39
00:02:49.960 --> 00:02:54.630
私たちが対処する必要がある難しい部分は、
ユーザーが多くのアプリケーションを持って
いるかもしれないということです。

40
00:02:56.482 --> 00:03:01.690
それでは、ユーザーとアプリのエンティティ
のクロス製品を見てみましょう。

41
00:03:01.690 --> 00:03:06.420
これは、データのいわゆる長い表現になりま
す。

42
00:03:06.420 --> 00:03:09.500
我々は、各ユーザーのアプリのペアの役割を
持つことになります。

43
00:03:10.750 --> 00:03:14.830
このテーブルを使用すると、自然にアプリの
平均エンコードを計算できます。

44
00:03:16.280 --> 00:03:24.210
だから今すべてのアプリは、ターゲットの平
均でエンコードされています, しかし、ど
のようにユーザーにそれをマップする.

45
00:03:24.210 --> 00:03:28.028
すべてのユーザーは、アプリケーションの数
を持っているので、

46
00:03:28.028 --> 00:03:31.979
app1
の代わりに、app2、app3、

47
00:03:31.979 --> 00:03:38.341
我々は今0.1、0.2、0.1
のようなベクトルを持っているでしょう。

48
00:03:38.341 --> 00:03:40.601
それはかなり簡単だった。

49
00:03:40.601 --> 00:03:45.259
我々は、平均のように、それらのベクトルか
ら様々な統計情報を収集することができます

50
00:03:45.259 --> 00:03:49.030
最小、最大、標準偏差など。

51
00:03:50.330 --> 00:03:55.040
これまでのところ我々は、我々のデータは、
内部構造を持っていないと仮定

52
00:03:55.040 --> 00:03:58.950
時系列では、明らかに将来の情報を使用する
ことができます。

53
00:03:59.950 --> 00:04:02.860
一方で、それは制限、

54
00:04:02.860 --> 00:04:07.640
一方で、それは実際に私達にある複雑な特徴
を作ることを可能にする。

55
00:04:08.970 --> 00:04:13.050
カテゴリをエンコードするときに時間コンポ
ーネントのないデータセットでは、

56
00:04:13.050 --> 00:04:18.350
我々は、統計を計算するためにすべてのルー
ルを使用するように強制されます。

57
00:04:18.350 --> 00:04:22.300
これは、ルールの一部のサブセットを選択す
る意味がありません。

58
00:04:22.300 --> 00:04:24.450
時間の存在はそれを変える。

59
00:04:24.450 --> 00:04:26.600
特定のカテゴリについては、我々はできませ
ん。

60
00:04:26.600 --> 00:04:31.220
たとえば、前の日から平均を計算し、前の2
日間、

61
00:04:31.220 --> 00:04:32.570
前週など

62
00:04:34.170 --> 00:04:35.190
例を考えてみましょう。

63
00:04:36.290 --> 00:04:42.048
ユーザーがお金を使うカテゴリを予測する必
要があります。

64
00:04:42.048 --> 00:04:47.540
この2つの例では、2日間の期間、2人のユ
ーザー、

65
00:04:47.540 --> 00:04:49.676
と3つの支出カテゴリ。

66
00:04:49.676 --> 00:04:54.582
いくつかの良い機能は、お金のユーザーの合
計金額になる

67
00:04:54.582 --> 00:04:57.130
前の日に過ごした。

68
00:04:57.130 --> 00:05:02.810
特定のカテゴリのすべてのユーザーが費やし
た平均金額。

69
00:05:02.810 --> 00:05:08.132
だから、1日目で、ユーザー101は $6
を費やして、

70
00:05:08.132 --> 00:05:10.876
ユーザー 102, $3.

71
00:05:10.876 --> 00:05:16.350
したがって、我々は2日目の将来の値として
、これらの数字を感じる。

72
00:05:16.350 --> 00:05:20.900
同様に、カテゴリ別の平均金額です。

73
00:05:22.070 --> 00:05:27.260
データが多ければ多いほど、より複雑な機能
が作成できます。

74
00:05:28.330 --> 00:05:32.750
実際には、それは多くの場合、数値機能をエ
ンコードすることを意味する公式されている

75
00:05:32.750 --> 00:05:35.580
機能のいくつかの組み合わせ。

76
00:05:35.580 --> 00:05:40.550
数値機能をエンコードするには、bin
にしてカテゴリとして扱う必要があります。

77
00:05:42.000 --> 00:05:45.170
さて、2つの質問に答える必要があります。

78
00:05:45.170 --> 00:05:48.142
まず、どのように数値機能を bin
に、および

79
00:05:48.142 --> 00:05:53.080
2番目の機能の便利な組み合わせを選択する
方法。

80
00:05:53.080 --> 00:06:01.235
木を分析することでモデルの構造から見つけ
出すことができる

81
00:06:01.235 --> 00:06:05.491
だから最初は、我々は例えば、[聞こえない
] モデルを取る

82
00:06:05.491 --> 00:06:08.459
エンコーディングなしの raw 機能。

83
00:06:08.459 --> 00:06:11.340
数字の特徴から始めましょう。

84
00:06:12.890 --> 00:06:17.780
数字の特徴が多くの [聞こえない] ポイ
ントを持っている場合、それはそれが持って
いることを意味します

85
00:06:17.780 --> 00:06:23.650
ターゲットとのいくつかの複雑な依存性と、
その符号化を意味しようとしていた。

86
00:06:23.650 --> 00:06:28.530
さらに、これらの正確なスプリットポイント
は、機能を bin
に使用することができます。

87
00:06:29.690 --> 00:06:32.280
モデル構造を解析することで、

88
00:06:32.280 --> 00:06:37.700
我々は、両方の不審な数字の機能を識別し、
それを bin に良い方法を発見した。

89
00:06:39.470 --> 00:06:43.350
これは、相互作用を選択すると少し難しくな
るだろうが、

90
00:06:43.350 --> 00:06:44.380
何も特別な。

91
00:06:45.790 --> 00:06:51.000
まず、デシジョンツリーからの相互作用への
抽出方法を定義します。

92
00:06:52.030 --> 00:06:57.750
このプロセスは、3つの方法、4つの方法の
任意の方法の相互作用に似ています。

93
00:06:59.360 --> 00:07:06.810
2つの機能がツリー内で相互作用するのは、
近隣の2点のノートにある場合です。

94
00:07:06.810 --> 00:07:11.880
そのことを念頭において、我々は、モデル内
のすべての木を反復処理することができます

95
00:07:11.880 --> 00:07:15.850
各フィーチャの相互作用が出現した回数を計
算します。

96
00:07:16.850 --> 00:07:21.225
最も頻繁な相互作用はおそらく平均符号化の
価値がある。

97
00:07:21.225 --> 00:07:27.105
たとえば、フィーチャ1とフィーチャ2ペア
が最も頻繁に発生していることが判明した場
合、

98
00:07:27.105 --> 00:07:31.735
その後、我々のデータでは、これらの機能の
値を連結することができます。

99
00:07:31.735 --> 00:07:34.015
結果の相互作用をエンコードすることを意味
します。

100
00:07:35.905 --> 00:07:39.695
では、相互作用のエンコーディングの重要性
を説明しましょう。

101
00:07:40.840 --> 00:07:46.370
Amazon の従業員アクセスチャレンジ
コンペティションは、非常に特定のデータセ
ットを持っています。

102
00:07:46.370 --> 00:07:49.565
唯一の9つのカテゴリの機能があります。

103
00:07:49.565 --> 00:07:54.387
我々は盲目的に raw 機能に GBM
モデルのように言うフィットする場合、

104
00:07:54.387 --> 00:07:58.287
どんなにパラメータを返しても

105
00:07:58.287 --> 00:08:02.490
我々は 0.87 AUC
の範囲で得点します。

106
00:08:02.490 --> 00:08:07.070
これは、リーダーボード上の700の位置に
大まかに配置されます。

107
00:08:08.160 --> 00:08:13.970
さらに、すべてのラベルをエンコードするこ
とを意味しても、何の進展もありません。

108
00:08:14.981 --> 00:08:20.755
しかし、我々は猫ブーストモデルに適合する
場合は、内部

109
00:08:20.755 --> 00:08:25.975
意味は、いくつかの機能の相互作用をエンコ
ードすると、我々はすぐに0.91
の範囲で得点する

110
00:08:25.975 --> 00:08:31.765
これは、この位置に勝つ上に私たちを配置し
ます。

111
00:08:31.765 --> 00:08:35.555
絶対 AUC 値との差

112
00:08:35.555 --> 00:08:38.600
相対的なスコアボードの位置は驚異的です。

113
00:08:39.910 --> 00:08:43.650
また、猫ブーストは銀の弾丸であることに注
意してください。

114
00:08:43.650 --> 00:08:46.720
リーダーボードでさらに高くなるためには、

115
00:08:46.720 --> 00:08:51.140
まだ手動でより多くの平均エンコードされた
相互作用を追加する必要があります。

116
00:08:52.190 --> 00:08:56.770
一般的に、カテゴリーの多いコンクールに参
加すれば

117
00:08:56.770 --> 00:09:04.160
変数は、常に相互作用と平均符号化を使用し
ようとする価値がある。

118
00:09:04.160 --> 00:09:07.520
私はまた、正しい検証プロセスについて思い
出させたい。

119
00:09:08.550 --> 00:09:11.164
すべてのローカル実験の間に、

120
00:09:11.164 --> 00:09:15.820
最初に X_tr と X_val
パーツのデータを分割する必要があります。

121
00:09:16.830 --> 00:09:21.717
X_tr
のエンコーディングを推定し、それらを
X_tr にマップし、

122
00:09:21.717 --> 00:09:26.150
X_val し、X_tr
にそれらを定例化

123
00:09:26.150 --> 00:09:32.080
その後にのみ X_tr/X_val
分割でモデルを検証します。

124
00:09:32.080 --> 00:09:36.490
データを分割する前に、エンコードの見積も
りについても考えないでください。

125
00:09:37.860 --> 00:09:43.900
また、送信ステージでは、全列車データのエ
ンコードを見積もることができます。

126
00:09:43.900 --> 00:09:47.040
それを電車やテストにマップし、

127
00:09:47.040 --> 00:09:52.790
次に、トレーニングデータに正規化を適用し
、最終的にモデルに合わせます。

128
00:09:52.790 --> 00:09:57.710
そして、あなたはすでに正則化の方法を決定
している必要があります注意

129
00:09:57.710 --> 00:09:59.670
ローカル実験の強さ。

130
00:10:01.190 --> 00:10:05.040
このセクションの最後に、主な利点をまとめ
てみましょう。

131
00:10:05.040 --> 00:10:06.710
平均符号化の不利な点。

132
00:10:08.350 --> 00:10:08.955
最初です

133
00:10:08.955 --> 00:10:15.490
平均符号化は、私たちはカテゴリ変数のコン
パクトな変換を行うことができます。

134
00:10:15.490 --> 00:10:18.530
それはまた特徴工学のための強力な基礎であ
る。

135
00:10:19.620 --> 00:10:23.510
それから主な不利な点はターゲット反乱の漏
出である。

136
00:10:23.510 --> 00:10:27.320
我々は、検証と
irregularization
に非常に注意する必要があります。

137
00:10:29.100 --> 00:10:32.470
また、特定のデータセットでのみ動作します
。

138
00:10:32.470 --> 00:10:36.270
それは間違いなくすべての競争に役立つこと
はありません。

139
00:10:36.270 --> 00:10:42.740
ただし、この方法が機能すると、大幅な改善
が生じる可能性があることに注意してくださ
い。

140
00:10:42.740 --> 00:10:44.038
ご注意をありがとうございました。

141
00:10:44.038 --> 00:10:54.038
音楽

