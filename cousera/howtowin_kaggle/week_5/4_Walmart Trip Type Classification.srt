1
00:00:03.010 --> 00:00:05.620
こんにちは。このビデオでは、

2
00:00:05.620 --> 00:00:06.845
私は話をするつもりです

3
00:00:06.845 --> 00:00:12.380
年前の Kaggle カップルで開催され
たウォルマートの旅行型分類の挑戦。

4
00:00:12.380 --> 00:00:14.795
私はその競技で1位を獲得した。

5
00:00:14.795 --> 00:00:17.990
そして今、私はの最も興味深い部分について
教えてくれます

6
00:00:17.990 --> 00:00:21.704
問題と私の解決策について。

7
00:00:21.704 --> 00:00:25.814
つまり、このプレゼンテーションは4つの部
分で構成されています。

8
00:00:25.814 --> 00:00:28.100
まず、問題を述べます。

9
00:00:28.100 --> 00:00:31.699
第二に、我々はどのようなデータフォーマッ
トとデータの再処理を理解する。

10
00:00:31.699 --> 00:00:35.570
第3に、モデルについてお話します。

11
00:00:35.570 --> 00:00:39.665
その相対的な品質と一般のカシメスキームと
の関係。

12
00:00:39.665 --> 00:00:44.285
そして最後に、我々はここに新機能を生成す
るいくつかの可能性を概説します。

13
00:00:44.285 --> 00:00:46.605
では、始めましょう。

14
00:00:46.605 --> 00:00:52.400
私たちのデータでは、我々はウォルマートで
2週間で自分の店を訪問した購入の人々があ
った

15
00:00:52.400 --> 00:00:58.620
そして、我々は38の訪問旅行の種類やクラ
スにそれらを分類しなければならなかった。

16
00:00:58.620 --> 00:01:01.985
のは、データ内の機能を簡単に見てみましょ
う。

17
00:01:01.985 --> 00:01:04.947
トリップタイプ列はターゲットを表し、

18
00:01:04.947 --> 00:01:08.110
訪問番号は、結合する ID を表します。

19
00:01:08.110 --> 00:01:12.075
1つのショッピング旅行で1つの顧客によっ
て行われた購入。

20
00:01:12.075 --> 00:01:15.785
たとえば、訪問番号7を作った顧客は、

21
00:01:15.785 --> 00:01:18.470
に配置されている2つの項目を購入

22
00:01:18.470 --> 00:01:21.890
このデータフレームの3番目の行にあります
。

23
00:01:21.890 --> 00:01:26.319
同じ訪問番号を持つすべての行に同じトリッ
プタイプがあることに注意してください。

24
00:01:26.319 --> 00:01:32.383
重要な瞬間は、我々は訪問番号の旅行の種類
を予測する必要があることです

25
00:01:32.383 --> 00:01:35.325
そして列車データの各行のためではない。

26
00:01:35.325 --> 00:01:36.920
見ての通り

27
00:01:36.920 --> 00:01:42.850
電車の中で我々は約647000を持ってい
る

28
00:01:42.850 --> 00:01:49.305
行とのみ95000の訪問。

29
00:01:49.305 --> 00:01:51.085
機能に戻る, 次の機能は、平日です

30
00:01:51.085 --> 00:01:54.030
明らかに訪問の平日を表しています。

31
00:01:54.030 --> 00:01:55.980
次は UPC です。

32
00:01:55.980 --> 00:01:59.635
UPC は、購入したアイテムの正確な
ID です。

33
00:01:59.635 --> 00:02:01.742
次に、スキャンカウント。

34
00:02:01.742 --> 00:02:05.408
スキャン数は、購入したアイテムの正確な数
です。

35
00:02:05.408 --> 00:02:10.420
ここでマイナス1は購入ではなく返品を表し
ていることに注意してください。

36
00:02:10.420 --> 00:02:13.285
次の機能、部門の説明、

37
00:02:13.285 --> 00:02:18.330
と68ユニークな値は、項目のための広いカ
テゴリです。

38
00:02:18.330 --> 00:02:20.307
そして最後に、fineline 番号、

39
00:02:20.307 --> 00:02:22.670
約5000のユニークな値で、

40
00:02:22.670 --> 00:02:25.950
は、アイテムのより洗練されたカテゴリです
。

41
00:02:25.950 --> 00:02:29.095
この機能が何を表しているかを理解した後、

42
00:02:29.095 --> 00:02:33.655
訪問番号ごとに1つの予測を行う必要がある
ことを思い出してみましょう。

43
00:02:33.655 --> 00:02:37.255
のは、訪問番号8のデータを見てみましょう
。

44
00:02:37.255 --> 00:02:39.565
我々はここを見ることができます

45
00:02:39.565 --> 00:02:44.315
この特定の訪問は、カテゴリの塗料やアクセ
サリーの購入がたくさんある

46
00:02:44.315 --> 00:02:47.920
つまり、トリップタイプ番号26は、

47
00:02:47.920 --> 00:02:52.360
そのカテゴリ内のほとんどの購入を訪問を表
します。

48
00:02:52.360 --> 00:02:55.465
さて、ここで鉄道模型にアプローチする方法
。

49
00:02:55.465 --> 00:02:59.525
データをもう一度見て、可能性を評価してみ
ましょう。

50
00:02:59.525 --> 00:03:05.027
我々は、リスト上の各項目のトリップタイプ
を予測するか、我々は別の方法を選択する必
要がありますか?

51
00:03:05.027 --> 00:03:07.637
もちろん二人とも可能ですが、

52
00:03:07.637 --> 00:03:09.095
でも最初のうちは

53
00:03:09.095 --> 00:03:13.428
各データセットを使用して各行のトリップタ
イプを予測し、

54
00:03:13.428 --> 00:03:18.170
私達は同じ訪問に属する項目間の重要な相互
作用を逃す。

55
00:03:18.170 --> 00:03:22.223
例えば、トリップタイプは、26の数がある
かもしれませんが、

56
00:03:22.223 --> 00:03:27.309
その項目の半分以上の場合は、塗料やアクセ
サリーからです。

57
00:03:27.309 --> 00:03:31.170
しかし、我々はこれらの項目間の相互作用を
考慮しない場合は、

58
00:03:31.170 --> 00:03:33.580
それはかなり予測するのは難しいことができ
ます。

59
00:03:33.580 --> 00:03:38.155
だから、訪問とメイキングですべての購入を
結合する2番目のオプション

60
00:03:38.155 --> 00:03:43.250
各行が完全な訪問を表すデータセットは、よ
り合理的なようです。

61
00:03:43.250 --> 00:03:45.658
と、期待できるように、

62
00:03:45.658 --> 00:03:51.375
このアプローチは、競争の中でより重要な利
点につながります。

63
00:03:51.375 --> 00:03:56.330
私はあなたの目的の1つにデータ形式を変更
する最も簡単な方法を示すつもりです。

64
00:03:56.330 --> 00:04:00.815
例を目的として、部署の説明機能を選択して
みましょう。

65
00:04:00.815 --> 00:04:04.900
まず、データフレームを訪問番号でグループ
化して、

66
00:04:04.900 --> 00:04:09.915
各部門の説明が訪問に何回存在するかを計算
します。

67
00:04:09.915 --> 00:04:14.010
では、最後のグループを unstack
てみましょう。

68
00:04:14.010 --> 00:04:19.285
列ので、各部門の説明値の一意の列を取得し
ます。

69
00:04:19.285 --> 00:04:22.210
今、これは我々が欲しかった形式です。

70
00:04:22.210 --> 00:04:27.645
各行は訪問を表し、各列はその訪問で説明さ
れている機能です。

71
00:04:27.645 --> 00:04:32.710
我々は、部門の説明以外の他の機能のアプロ
ーチでこのグループを使用することができま
す。

72
00:04:32.710 --> 00:04:39.755
また、訪問中の項目は、実際にはテキスト内
の単語に非常に似ていることに注意してくだ
さい。

73
00:04:39.755 --> 00:04:44.680
我々の確認後、各機能は、ここでカウントを
表し、

74
00:04:44.680 --> 00:04:47.865
だから、通常のテキストで動作するアイデア
を適用することが、

75
00:04:47.865 --> 00:04:51.215
たとえば、tf-idf 変換。

76
00:04:51.215 --> 00:04:55.565
お察しのとおり、多くの可能性がここに出て
くる。

77
00:04:55.565 --> 00:05:00.999
すごい。これが行われ、我々は所望の形式で
データを処理した後、

78
00:05:00.999 --> 00:05:03.100
モデル選びに移りましょう。

79
00:05:03.100 --> 00:05:05.750
すでに話し合ったことを踏まえて、

80
00:05:05.750 --> 00:05:08.620
もし我々が大きな違いを期待する必要があり
ます推測することができます

81
00:05:08.620 --> 00:05:12.485
線形モデルとツリーベースのモデルの間のス
コアはここですか?

82
00:05:12.485 --> 00:05:15.715
これについて少し考えてみてください。

83
00:05:15.715 --> 00:05:19.795
たとえば、線形モデルが

84
00:05:19.795 --> 00:05:24.745
ツリーベースのモデルと比較して実行します
か?はい、あります。

85
00:05:24.745 --> 00:05:27.785
繰り返しますが、私はここでの相互作用につ
いて話している。

86
00:05:27.785 --> 00:05:31.120
実際、ニューラルネットワークにおける木ベ
ースのモデルは、

87
00:05:31.120 --> 00:05:36.315
この非常に理由のためにこの競争の中で品質
の重要な優位性。

88
00:05:36.315 --> 00:05:42.855
しかし、それでも、1つは便利なメソッドの
機能をここに生成する線形モデルと TNN
を使用することができます。

89
00:05:42.855 --> 00:05:46.430
彼らは相互作用を意味していないという事実
にもかかわらず、

90
00:05:46.430 --> 00:05:50.230
彼らは私の一般的な賭けのスキームで貴重な
資産だった。

91
00:05:50.230 --> 00:05:54.295
私たちはここで賭けの詳細に行くことはあり
ませんので、

92
00:05:54.295 --> 00:05:58.590
既に競争についての他のビデオのほとんどの
考えを覆った。

93
00:05:58.590 --> 00:06:03.165
その代わりに、機能の生成について少し話し
ます。

94
00:06:03.165 --> 00:06:07.798
1回の来店で購入した項目間のやりとり以外
は、

95
00:06:07.798 --> 00:06:10.975
1つは機能間の相互作用を利用することを試
みることができる。

96
00:06:10.975 --> 00:06:15.290
ここで面白いと予想外の結果は、

97
00:06:15.290 --> 00:06:19.993
1つの fineline 番号は複数の部
門の記述に属することができる

98
00:06:19.993 --> 00:06:23.345
つまり、fineline 番号は

99
00:06:23.345 --> 00:06:28.195
あなたが考えることができるように、より詳
細な部門の説明。

100
00:06:28.195 --> 00:06:33.200
この相互作用を使用して、1つは彼のモデル
を更に改善できる。

101
00:06:33.200 --> 00:06:35.536
もう一つの興味深い特徴の生成の考え

102
00:06:35.536 --> 00:06:38.875
データの時間構造に接続した。

103
00:06:38.875 --> 00:06:41.895
このプロットを見てください,

104
00:06:41.895 --> 00:06:46.395
これは、行番号に対する曜日機能の変更を表
します。

105
00:06:46.395 --> 00:06:50.230
これは、データが時間によってここに注文さ
れているように見えます。

106
00:06:50.230 --> 00:06:54.210
データは31日で構成されています。

107
00:06:54.210 --> 00:06:57.350
しかし、列車のテストの分割時間ベースでは
なかった。

108
00:06:57.350 --> 00:07:02.533
そのため、データセットの日番号のような機
能を派生させることができ、

109
00:07:02.533 --> 00:07:04.940
1日の訪問数、

110
00:07:04.940 --> 00:07:08.645
と一日の訪問の合計金額。

111
00:07:08.645 --> 00:07:10.970
だから、これは。

112
00:07:10.970 --> 00:07:15.350
私達はちょうどこの競争の最も興味深い部分
を論議した。

113
00:07:15.350 --> 00:07:18.425
データ形式をより適切に変更すると、

114
00:07:18.425 --> 00:07:21.214
販売しながら機能を生成する、

115
00:07:21.214 --> 00:07:24.300
積み重ねをしながらモデルを操作する。

116
00:07:24.300 --> 00:07:28.365
そして最後に、追加の機能エンジニアリング
のいくつかを行う。

117
00:07:28.365 --> 00:07:32.395
挑戦自体は有用、興味深い証明した。

118
00:07:32.395 --> 00:07:38.770
そして、私はそれをチェックアウトし、我々
が話しているアプローチを試してみることを
お勧めします。

