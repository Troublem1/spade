1
00:00:00.000 --> 00:00:02.350
これを手に入れたら

2
00:00:02.350 --> 00:00:04.945
物事はここからスムーズに行ったと思う、

3
00:00:04.945 --> 00:00:11.560
我々はすでに機能とモデルを生成するこれら
の手段を確立しているので、

4
00:00:11.560 --> 00:00:14.615
そして、彼らが良いかどうかを理解する方法
を知っている。

5
00:00:14.615 --> 00:00:21.270
推薦に共通するさまざまな戦略を展開しまし
た。

6
00:00:21.270 --> 00:00:24.430
まず、コンテンツベースのアプローチを使用
します。

7
00:00:24.430 --> 00:00:29.555
今、コンテンツベースのアプローチは、あな
たが作ることを前提としたものです

8
00:00:29.555 --> 00:00:36.655
の特徴に基づいて提言は、製品を言うことが
できます。

9
00:00:36.655 --> 00:00:41.970
なので、お客様がこれらの商品が好きなので
お勧めをして、

10
00:00:41.970 --> 00:00:45.360
この製品は、特定の機能を持っているので。

11
00:00:45.360 --> 00:00:47.580
例えば、甘いというか、

12
00:00:47.580 --> 00:00:48.650
それとも甘くない、

13
00:00:48.650 --> 00:00:51.580
またはそれが含まれて、私は知らない、

14
00:00:51.580 --> 00:00:53.885
チョコレートやチョコレートは含まれていま
せん。

15
00:00:53.885 --> 00:00:57.380
したがって、このアプローチに焦点を当て

16
00:00:57.380 --> 00:01:02.510
良い勧告をするために製品の特性。

17
00:01:02.510 --> 00:01:08.370
また、協調フィルタリングに基づく別の戦略
を展開しました。

18
00:01:08.370 --> 00:01:12.790
協調フィルタリングとは、この文脈において
、

19
00:01:12.790 --> 00:01:21.365
お客様が別のように見える方法に基づいて提
言を行ったこと、

20
00:01:21.365 --> 00:01:23.705
それは製品を購入する可能性が高い。

21
00:01:23.705 --> 00:01:27.450
そこで、我々は類似点について見て

22
00:01:27.450 --> 00:01:32.970
顧客は、彼らが特定の項目を希望するかどう
かを定義するために、

23
00:01:32.970 --> 00:01:36.565
アイテム自体の特性に基づいていません。

24
00:01:36.565 --> 00:01:40.715
そして、ハイブリッドのアプローチは、私た
ちが終わったものです

25
00:01:40.715 --> 00:01:43.365
これは基本的にこれらの2つの組み合わせで
す。

26
00:01:43.365 --> 00:01:46.750
したがって、最初のアプローチの詳細につい
ては、コンテンツベース。

27
00:01:46.750 --> 00:01:49.840
このアプローチの背後にある前提は何でした
か?

28
00:01:49.840 --> 00:01:54.895
ということは、同じ会社のブランドやカテゴ
リーから買ってきたお客様で、

29
00:01:54.895 --> 00:01:58.650
オファー製品を購入するより高いチャンスが
あるでしょう、

30
00:01:58.650 --> 00:02:00.840
そしてまた買います。

31
00:02:00.840 --> 00:02:03.780
なので、既に関係が強くなって

32
00:02:03.780 --> 00:02:07.465
は、この製品との取引履歴に基づいています
。

33
00:02:07.465 --> 00:02:10.100
この会社のブランドとカテゴリーの組み合わ
せでは、

34
00:02:10.100 --> 00:02:14.615
彼は同じ要素を持つ製品を購入する可能性が
高いほど、

35
00:02:14.615 --> 00:02:17.245
同じ要素を持つオファー。

36
00:02:17.245 --> 00:02:20.135
そして、例を見てみましょうここで、顧客、

37
00:02:20.135 --> 00:02:24.170
会社のブランドとカテゴリの同じ組み合わせ
から買ったことがない。

38
00:02:24.170 --> 00:02:28.255
多分彼または彼女は同じ会社やブランドから
買ってきた、

39
00:02:28.255 --> 00:02:30.290
または同じブランドからのみ。

40
00:02:30.290 --> 00:02:37.790
だから、我々は彼または彼女が同じブランド
または同じ会社を好きかどうかを判断する方
法があります。

41
00:02:37.790 --> 00:02:40.165
としましょう、我々はまったく持っていない
、と言う

42
00:02:40.165 --> 00:02:43.645
私達はまだこのブランドがいかに普及してい
るか知っている、

43
00:02:43.645 --> 00:02:45.660
またはどのように人気のあるこの会社は、

44
00:02:45.660 --> 00:02:49.545
またはどのように人気のある企業とブランド
の間の組み合わせです。

45
00:02:49.545 --> 00:02:53.310
従って、これはこのアプローチを運転するも
のである。

46
00:02:53.310 --> 00:02:58.970
なので、お客様がどれだけアイテムが好きか
、

47
00:02:58.970 --> 00:03:03.280
我々はすでに彼または彼女のトランザクショ
ンの履歴から見ることができるものに基づい
て。

48
00:03:03.280 --> 00:03:06.440
だから、我々は、この製品の階層を悪用しよ
うとした

49
00:03:06.440 --> 00:03:07.990
対顧客と時間。

50
00:03:07.990 --> 00:03:10.465
そして、なぜ私は、画像に時間をもたらす

51
00:03:10.465 --> 00:03:14.300
これは典型的な図式だと思うからです

52
00:03:14.300 --> 00:03:18.960
特定の製品の販売が時間を通して見るものの
。

53
00:03:18.960 --> 00:03:21.150
そして、あなたはそれが、非常に季節を見る
ことができます。

54
00:03:21.150 --> 00:03:24.125
だから、それはあなたが測定する場所が重要
です

55
00:03:24.125 --> 00:03:29.815
時間を通してマークするアイテムと顧客の関
係。

56
00:03:29.815 --> 00:03:34.635
故に彼または彼女は、過去のように頻繁にそ
れを購入していない可能性がありますので、

57
00:03:34.635 --> 00:03:37.250
またはそれはピーク期間ではないかもしれま
せん。

58
00:03:37.250 --> 00:03:40.250
アイスクリームかもしれないし、今では冬で
すが、

59
00:03:40.250 --> 00:03:43.725
なのでこの時期は売り上げが非常に高くなる
わけではありません。

60
00:03:43.725 --> 00:03:46.185
そのため、フィーチャを作成するときに、

61
00:03:46.185 --> 00:03:50.845
このラグの概念を考慮に入れる必要がありま
す。

62
00:03:50.845 --> 00:03:55.410
だから、時間を通してこの関係をマークする
には、

63
00:03:55.410 --> 00:03:57.185
これは、ラグの意味です。

64
00:03:57.185 --> 00:04:05.165
具体的には、いくつかの時間間隔を定義し、
これらに基づいてフィーチャを作成します。

65
00:04:05.165 --> 00:04:08.100
なので、お客さんが何回買ってきたかは

66
00:04:08.100 --> 00:04:11.800
過去30日で同じ会社のブランドやカテゴリ
ーから、

67
00:04:11.800 --> 00:04:14.500
その後、最後の60日、90で、

68
00:04:14.500 --> 00:04:17.475
120、半年、1年。

69
00:04:17.475 --> 00:04:19.615
そして、あなたはどのように変更を参照して
くださいしようとすると、

70
00:04:19.615 --> 00:04:23.195
これらの機能をすべて作成します。

71
00:04:23.195 --> 00:04:28.330
そして、クロス検証に基づいて、

72
00:04:28.330 --> 00:04:29.920
すでに確立していますが、

73
00:04:29.920 --> 00:04:33.770
これは、これらの機能のどれが便利かどうか
を見つけるのは簡単だった。

74
00:04:33.770 --> 00:04:37.685
だから、私はここに何百もの機能を作成し、

75
00:04:37.685 --> 00:04:40.880
そして、私はそれらを1つずつ追加していた
。

76
00:04:40.880 --> 00:04:45.360
私はこのクロス検証の方法を行っていた1つ
のオファーを残して、

77
00:04:45.360 --> 00:04:48.030
、すべての結果を連結します。

78
00:04:48.030 --> 00:04:49.610
測定すると、参照してください、

79
00:04:49.610 --> 00:04:53.465
1つの特徴の影響が AUC
に陽性だった場合、

80
00:04:53.465 --> 00:04:55.645
私は、その機能を残していた

81
00:04:55.645 --> 00:04:57.370
そうじゃなかったら

82
00:04:57.370 --> 00:05:00.450
私はそれを落としていたし、私は次の機能を
追加していた。

83
00:05:00.450 --> 00:05:03.660
だから、これはどのように機能が良かったか
を判断されます。

84
00:05:03.660 --> 00:05:09.880
これは、生成された機能のリストの小さなサ
ンプルです。

85
00:05:09.880 --> 00:05:14.390
そして、あなたは彼らがすべて非常に似てい
ることがわかります。

86
00:05:14.390 --> 00:05:15.830
みんなそのように見える

87
00:05:15.830 --> 00:05:17.420
なので、カテゴリーブランド30、

88
00:05:17.420 --> 00:05:19.005
どちらが上の1つの手段ですが、

89
00:05:19.005 --> 00:05:24.965
顧客が過去30日間に同じカテゴリとブラン
ドから何回購入したか。

90
00:05:24.965 --> 00:05:29.900
したがって、我々は、これらのタイプの完全
なリストを構築する

91
00:05:29.900 --> 00:05:35.315
機能と我々は、このクロス検証アプローチを
使用して、

92
00:05:35.315 --> 00:05:38.845
これらのどれが良かったかを判断する。

93
00:05:38.845 --> 00:05:42.120
私たちは明らかにいくつかのクリーニングで
した。

94
00:05:42.120 --> 00:05:46.565
もしいくつかのトランザクションが非常に大
きかったが、我々はそれらを締めくくった。

95
00:05:46.565 --> 00:05:50.000
また、私はマイナス1で欠損値を置き換え、

96
00:05:50.000 --> 00:05:55.475
そして、なぜ私はここで不足している値の多
くは、

97
00:05:55.475 --> 00:05:58.415
生成されたフィーチャから生成されました。

98
00:05:58.415 --> 00:06:04.300
だから、私は、トランザクションの歴史に戻
って、例えば、つもりだった

99
00:06:04.300 --> 00:06:08.305
私は、顧客がアイテムを購入する方法を何日
で表示されます

100
00:06:08.305 --> 00:06:10.615
またはカテゴリまたはブランド。

101
00:06:10.615 --> 00:06:14.600
そして、私はこれの標準偏差を作成しようと
します。

102
00:06:14.600 --> 00:06:16.300
レコードがない場合は、

103
00:06:16.300 --> 00:06:19.850
基本的に標準偏差を見積もることはできませ
ん。

104
00:06:19.850 --> 00:06:22.770
だから、この場合は、マイナス1を与える。

105
00:06:22.770 --> 00:06:24.335
マイナス1つは良い選択だった

106
00:06:24.335 --> 00:06:29.040
通常、これらはターゲットと負の関係を持っ
ていたので。

107
00:06:29.040 --> 00:06:34.730
従って、標準偏差のようなこれらの測定値を
推定できなかったとき、

108
00:06:34.730 --> 00:06:37.220
これは、多くの購入がなかったことを意味し
、

109
00:06:37.220 --> 00:06:39.855
これは、アイテムを購入する可能性が低いと
関連付けられていた、

110
00:06:39.855 --> 00:06:45.720
そして負の値は、この関係を反映していた。

111
00:06:45.720 --> 00:06:53.815
そして、何が面白かったのは、これはバイナ
リ分類の問題ですが、

112
00:06:53.815 --> 00:06:56.830
実際にはリッジ回帰を使用し、これをモデル
化します。

113
00:06:56.830 --> 00:06:59.190
なので、実際のレッテルとは別に、

114
00:06:59.190 --> 00:07:01.440
誰かが繰り返してきたかどうか、

115
00:07:01.440 --> 00:07:07.690
我々はまた、実際のカウントは、彼らが将来
的に何回繰り返していた。

116
00:07:07.690 --> 00:07:10.920
当然、これらはより強い情報を与える

117
00:07:10.920 --> 00:07:15.675
推薦がいかに成功したかについて、右か。

118
00:07:15.675 --> 00:07:18.335
何度も買ってきた人なので、

119
00:07:18.335 --> 00:07:20.810
これは、より成功した勧告だったことを意味
します。

120
00:07:20.810 --> 00:07:23.025
だから、この情報を知って、

121
00:07:23.025 --> 00:07:26.495
よりよい予言をするのを助けることができる
。

122
00:07:26.495 --> 00:07:29.145
差別良いスコアを持って、

123
00:07:29.145 --> 00:07:32.085
ゼロでも1でもモデルではありませんが、

124
00:07:32.085 --> 00:07:34.990
しかし、実際のカウントに。

125
00:07:34.990 --> 00:07:41.210
そして、これは、テストデータの0.61
の周りに teethed です。

126
00:07:41.210 --> 00:07:43.910
今、あなたは、このスコアが低いことを参照
してください

127
00:07:43.910 --> 00:07:46.795
しかし、これは単独でトップ10近くにあっ
た。

128
00:07:46.795 --> 00:07:51.490
これは自然にこの不規則性のために非常に低
かった。

129
00:07:51.490 --> 00:07:55.730
したがって、列車とテストデータの間にこれ
らのすべての大きな違い。

130
00:07:55.730 --> 00:07:59.840
2番目の方法は、協調フィルタリングを使用
します。

131
00:07:59.840 --> 00:08:03.725
私は、2番目のアプローチは、答えを試みた
ものだと思う

132
00:08:03.725 --> 00:08:08.350
とジャレットは、主にこれに焦点を当ててい
た、された

133
00:08:08.350 --> 00:08:14.250
顧客は提供を受け取らなかったらプロダクト
を買ったか。

134
00:08:14.250 --> 00:08:18.910
従って、それらは提供にもかかわらずプロダ
クトをとにかく買った、

135
00:08:18.910 --> 00:08:21.640
クーポンを送るのに関係なく?

136
00:08:21.640 --> 00:08:24.215
私は非常に興味深い概念だったと思う。

137
00:08:24.215 --> 00:08:29.465
これが行われた、このアプローチは

138
00:08:29.465 --> 00:08:37.010
列車とテストデータのすべてのオファーのた
めの別のモデルを作ることによって採用。

139
00:08:37.010 --> 00:08:41.280
そして、ターゲット変数は非常に直感的だっ
た

140
00:08:41.280 --> 00:08:48.195
実際のクーポンが送られてきた90日前に行
ったので、

141
00:08:48.195 --> 00:08:55.985
そして私達は顧客が同じ提供されたプロダク
トから何回購入したか推定した、

142
00:08:55.985 --> 00:08:59.775
だから、カテゴリのブランドと会社の同じ組
み合わせから。

143
00:08:59.775 --> 00:09:01.730
だから我々は独自の標的を作った

144
00:09:01.730 --> 00:09:03.975
なので、クーポンの送付に関わらず、

145
00:09:03.975 --> 00:09:06.505
とりあえずこの情報は無視しましょう。

146
00:09:06.505 --> 00:09:09.820
我々は、90日前に知っている

147
00:09:09.820 --> 00:09:14.855
クーポンは、我々は顧客が提供する製品を購
入知って送信されます。

148
00:09:14.855 --> 00:09:17.275
彼らが持っているどのような特性を見てみま
しょう。

149
00:09:17.275 --> 00:09:21.035
我々はここにリンクを作るために管理する場
合

150
00:09:21.035 --> 00:09:25.620
クーポンに関係なく製品のようなお客様から
、

151
00:09:25.620 --> 00:09:31.460
して、実際には、クーポンを送信された顧客
にこのスコアを適用する

152
00:09:31.460 --> 00:09:35.540
たぶん、その得点は、それが話すので本当に
よく働きます

153
00:09:35.540 --> 00:09:41.805
クーポンに関係なく、お客様が本当に気に入
ったあなた。

154
00:09:41.805 --> 00:09:45.350
だから、これらのアプローチの主なロジック
は、

155
00:09:45.350 --> 00:09:46.730
そしてそれは本当にうまくいった。

156
00:09:46.730 --> 00:09:50.230
それは他のアプローチと本当にうまくブレン
ド。

157
00:09:50.230 --> 00:09:56.725
だから、この2つの組み合わせは、この競争
の中で非常に強力なリードを与える。

158
00:09:56.725 --> 00:09:59.820
ここでのすべての機能は、当然のことながら
、

159
00:09:59.820 --> 00:10:02.225
彼らは協調フィルタリングに基づいていたの
で、

160
00:10:02.225 --> 00:10:04.460
すべての顧客に焦点を当てていた。

161
00:10:04.460 --> 00:10:06.835
したがって、ユーザーの活動に焦点を当てた
。

162
00:10:06.835 --> 00:10:10.320
従って彼らは顧客を記述することを試みる

163
00:10:10.320 --> 00:10:16.040
どのカテゴリまたはブランドや彼または彼女
が購入することを好む企業。

164
00:10:16.040 --> 00:10:25.330
そして、これらのカテゴリについては、我々
は、多くの歴史を持っていなかった

165
00:10:25.330 --> 00:10:30.335
彼らがどれだけ好きかについての情報の要約
を得ることができますか?

166
00:10:30.335 --> 00:10:32.275
彼らはかなり多かったので、

167
00:10:32.275 --> 00:10:37.180
そして、何が非常に成功した制限ボルツマン
マシンを使用している

168
00:10:37.180 --> 00:10:38.855
深い学問の形である

169
00:10:38.855 --> 00:10:43.840
これらの最も人気のあるカテゴリのためにこ
の情報をまとめるために、

170
00:10:43.840 --> 00:10:46.725
彼らは自然にバイナリ機能で動作するため、

171
00:10:46.725 --> 00:10:52.780
これは、顧客が購入しているかどうかは、特
定のカテゴリの周りからだった。

172
00:10:52.780 --> 00:11:00.990
我々はモデルのこのタイプの勧告で使用され
て見たので、最初のアイデアだった

173
00:11:00.990 --> 00:11:02.900
Chintan が使ってた

174
00:11:02.900 --> 00:11:06.990
しかし、我々はそれが監督の問題として動作
させることができなかったが、

175
00:11:06.990 --> 00:11:12.680
私たちは、教師なしの問題をまとめるために
、このフォームとして本当にうまく機能した

176
00:11:12.680 --> 00:11:22.925
顧客が特定のカテゴリやブランドや企業を好
む方法の活動。

177
00:11:22.925 --> 00:11:29.075
その後、平均額の支出のような他の機能を作
成し、

178
00:11:29.075 --> 00:11:32.950
合計訪問数、どのように多くの異なるブラン
ドから、

179
00:11:32.950 --> 00:11:37.380
カテゴリ、および彼らが購入する企業は、彼
らが極端である、

180
00:11:37.380 --> 00:11:42.110
彼らは冒険ですか、彼らは多くの異なるブラ
ンドやカテゴリまたはわずか数を試してくだ
さい。

181
00:11:42.110 --> 00:11:43.670
なのでこういう情報は、

182
00:11:43.670 --> 00:11:47.945
我々は、顧客の基数の不足を駆動しようとし
ている。

183
00:11:47.945 --> 00:11:51.765
そして、彼らは割引かどうかを好むかどうか
、

184
00:11:51.765 --> 00:11:53.260
彼らは週末を訪問する場合は、

185
00:11:53.260 --> 00:11:55.040
彼らは週末にどのくらい過ごす?

186
00:11:55.040 --> 00:11:59.850
我々は、さまざまな方法で顧客を記述しよう
とすると、

187
00:11:59.850 --> 00:12:01.865
異なる角度からのように。

188
00:12:01.865 --> 00:12:04.715
そして、すべてのこれらの機能が構築されて
いる、

189
00:12:04.715 --> 00:12:08.370
繰り返しますが、のような概念が2つあった

190
00:12:08.370 --> 00:12:15.590
最高のモデリング技術は、それがログのサイ
クルフレームからマシンをブーストで実行さ
れた

191
00:12:15.590 --> 00:12:23.685
何度も同じカテゴリーのカウント、

192
00:12:23.685 --> 00:12:29.715
ブランド、および会社はクーポンが送られた
90日前に買われた。

193
00:12:29.715 --> 00:12:34.830
自然対数は、正則化の形として役立っていた
と思います。

194
00:12:34.830 --> 00:12:36.945
だから、非常に極端な値を数えていた。

195
00:12:36.945 --> 00:12:39.095
それは、このタイプの問題で本当によく働き
ました。

196
00:12:39.095 --> 00:12:41.810
それは常に後押しを得ていた。

197
00:12:41.810 --> 00:12:45.890
これは、コンテンツベースのアプローチより
もわずかに優れた達成

198
00:12:45.890 --> 00:12:51.235
再びトップ10のスコア0616のレベルの
近くに、

199
00:12:51.235 --> 00:12:55.905
そして、私はこのアプローチは非常に、非常
に、非常に直感的だったと思う。

200
00:12:55.905 --> 00:12:58.835
どうやってこれをマージするの?

201
00:12:58.835 --> 00:13:04.290
我々はこれらの2つのスコアをマージしよう
としたときに我々が見つけた主な問題は、

202
00:13:04.290 --> 00:13:05.925
彼らは別のターゲットで訓練された。

203
00:13:05.925 --> 00:13:10.930
だから、コンテンツベースのアプローチは、
実際のアカウントに訓練された

204
00:13:10.930 --> 00:13:16.160
顧客が何回アイテムを購入したかを繰り返し
ていた。

205
00:13:16.160 --> 00:13:19.590
のカウントのログに2番目の1つ

206
00:13:19.590 --> 00:13:26.860
クーポンが送られた90日前に何回以上の製
品が買われたか。

207
00:13:26.860 --> 00:13:32.170
だから、このコースの分布を想像することが
できます非常に異なっている、自然に、

208
00:13:32.170 --> 00:13:35.110
自然対数が値を押すので

209
00:13:35.110 --> 00:13:39.750
低は、これらのスコアは、最初のものよりも
はるかに低かった。

210
00:13:39.750 --> 00:13:42.820
しかし、ディストリビューションを見ると、

211
00:13:42.820 --> 00:13:44.050
点数は無視しましょう。

212
00:13:44.050 --> 00:13:46.000
我々は戦略2を知っている

213
00:13:46.000 --> 00:13:47.670
これは、右ここでは、

214
00:13:47.670 --> 00:13:53.700
特定のオファーは、左側のものよりも低いス
コアを持つことについては、

215
00:13:53.700 --> 00:13:55.465
これは、コンテンツベースのアプローチです
。

216
00:13:55.465 --> 00:14:00.920
しかし、分布は、これらの要素を無視する場
合は、ランクだけを見て、

217
00:14:00.920 --> 00:14:03.530
ループは、実際にはかなり似ています。

218
00:14:03.530 --> 00:14:05.380
だから点数は無視しましょう。

219
00:14:05.380 --> 00:14:08.470
スコアを相対的にしましょう。

220
00:14:08.470 --> 00:14:12.440
あなただけのランキングを見れば、彼らは実
際に似て見えます。

221
00:14:12.440 --> 00:14:14.400
そして、これは私たちのアイデアを与えた

222
00:14:14.400 --> 00:14:16.835
そして、あなたが参照してください、実際に
ランクを気に。

223
00:14:16.835 --> 00:14:19.370
だから、どのように良いのランクです。

224
00:14:19.370 --> 00:14:23.235
だから我々はランクに私たちのスコアを変換
されました。

225
00:14:23.235 --> 00:14:25.610
だから、実際のスコアが何であるかではなく
、

226
00:14:25.610 --> 00:14:30.295
しかし、どのように大きなスコアは、我々が
持っている他のすべてのスコアと比較される

227
00:14:30.295 --> 00:14:32.525
それは50、

228
00:14:32.525 --> 00:14:35.080
50位、もしくはトップスコアですが、

229
00:14:35.080 --> 00:14:36.935
2位ベスト、3位ベスト?

230
00:14:36.935 --> 00:14:40.425
ちょうどこの教区にランクを変換します。

231
00:14:40.425 --> 00:14:44.945
そして、我々は、マージを行う平均でマージ
します。

232
00:14:44.945 --> 00:14:47.840
そして、あなたは最終的な結果を見ることが
できます。

233
00:14:47.840 --> 00:14:52.650
したがって、ランクに変換した後、これらの
2つのアプローチをブレンド

234
00:14:52.650 --> 00:14:58.220
と等しい重量を与える私たちのリーダーボー
ドのトップスコアを与えた。

235
00:14:58.220 --> 00:15:01.345
と私はクライアントと思う、

236
00:15:01.345 --> 00:15:04.790
他のチームとは違う形だ

237
00:15:04.790 --> 00:15:08.335
そして、我々は非常に早く、これを得た

238
00:15:08.335 --> 00:15:10.750
そして、我々はそのリードを快適に維持する
。

239
00:15:10.750 --> 00:15:13.730
そして、私は最後に到達しているとして、

240
00:15:13.730 --> 00:15:20.720
私が対処したかったのは、機械学習が得意で
、素晴らしいですが、時には、

241
00:15:20.720 --> 00:15:23.015
あなたは本当にデータに目を通す必要がある
、

242
00:15:23.015 --> 00:15:28.265
そして、これはこの要素が実際に流行した例
です。

243
00:15:28.265 --> 00:15:31.390
これは、データを理解するという概念だった

244
00:15:31.390 --> 00:15:35.270
電車とテストの違いを理解するの。

245
00:15:35.270 --> 00:15:41.070
それは本当に最高の可能性が検証戦略を越え
て形成することが重要だった

246
00:15:41.070 --> 00:15:47.725
テスト結果を複製し、その後、我々は何をし
ようと自信を与える

247
00:15:47.725 --> 00:15:53.430
それはうまく機能し、それはよく非観察デー
タを一般化する。

248
00:15:53.430 --> 00:15:58.050
それから、その問題にチャレンジされている
時に、

249
00:15:58.050 --> 00:16:02.330
あなたは伝統的に最高の仕事をしているもの
でそれを解決しようとする。

250
00:16:02.330 --> 00:16:07.065
そして、それは文学に頼るここで勧告の問題
だったので、

251
00:16:07.065 --> 00:16:10.200
過去にうまくいったことを頼って、例えば、

252
00:16:10.200 --> 00:16:13.375
このコンテンツベースのアプローチまたは協
調フィルタリングは、

253
00:16:13.375 --> 00:16:18.420
良い結果を得るために重要だった。

254
00:16:18.420 --> 00:16:23.695
最終的には、はい、高度な機械学習技術に頼
るも私たちにネットを与えた。

255
00:16:23.695 --> 00:16:25.895
深い学びを上手に活用した、

256
00:16:25.895 --> 00:16:28.050
勾配昇圧方式の使用、

257
00:16:28.050 --> 00:16:35.175
しかし、さらに簡単な方法はここでも機能の
ように他の側面に焦点を当てて動作します。

258
00:16:35.175 --> 00:16:38.620
それで良かった私はそれが有用見つけること
を望む。

259
00:16:38.620 --> 00:16:42.720
これらの要素は、私は本当にこれから奪うこ
とを望んでいた、

260
00:16:42.720 --> 00:16:47.390
我々はこのセットアップに挑戦する方法、

261
00:16:47.390 --> 00:16:50.615
どのように我々は、問題を押収しようとする
と、

262
00:16:50.615 --> 00:16:56.145
どうやってそれを理解して自分たちで作るか

263
00:16:56.145 --> 00:16:59.765
それを解決するために完全にそれを理解しな
さい。

264
00:16:59.765 --> 00:17:02.490
私たちはこの問題に身を置いた。

265
00:17:02.490 --> 00:17:07.010
うまくいけば、あなたはそれが役に立つと期
待し、より多くのものをご利用いただけます
。

