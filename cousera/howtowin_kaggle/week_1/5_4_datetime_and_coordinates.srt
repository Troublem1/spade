1
00:00:04.110 --> 00:00:04.850
こんにちは。

2
00:00:04.850 --> 00:00:08.795
このビデオでは、基本的なビジュアル生成ア
プローチについて説明します。

3
00:00:08.795 --> 00:00:11.710
datetime と座標の機能。

4
00:00:11.710 --> 00:00:16.230
これらの両方は、数値およびカテゴリの機能
とは大きく異なります。

5
00:00:16.230 --> 00:00:21.160
datetime
と座標の意味を解釈することができるので、

6
00:00:21.160 --> 00:00:25.650
我々はここで議論します将来の世代について
の具体的なアイデアをアップ。

7
00:00:25.650 --> 00:00:27.760
次に、datetime
から始めましょう。

8
00:00:29.030 --> 00:00:33.200
それはあなたの性質に依存していないため、
Datetime はかなり明確な機能です

9
00:00:33.200 --> 00:00:38.390
また、年、日または週のようないくつかの異
なる層を持っています。

10
00:00:38.390 --> 00:00:42.990
datetime から生成される新機能の
ほとんどは、2つのカテゴリに分けることが
できます。

11
00:00:42.990 --> 00:00:45.940
最初の1つ、期間内の時間の瞬間、および

12
00:00:45.940 --> 00:00:50.050
2つ目は、時間が特定のイベントから渡され
ます。

13
00:00:50.050 --> 00:00:51.720
最初の1つは非常に簡単です。

14
00:00:51.720 --> 00:00:56.680
我々は、1週間で2番目、分、時間、日のよ
うな機能を追加することができます

15
00:00:56.680 --> 00:00:59.600
月に、年などなどなど。

16
00:01:00.630 --> 00:01:04.434
これは、データ内の繰り返しパターンをキャ
プチャする場合に便利です。

17
00:01:04.434 --> 00:01:08.754
我々は、データに影響を与えるいくつかの非
一般的な材料について知っていれば、

18
00:01:08.754 --> 00:01:10.198
我々は同様にそれらを追加することができま
す。

19
00:01:10.198 --> 00:01:14.682
例えば、我々は薬の効率を予測することです
が、

20
00:01:14.682 --> 00:01:18.188
患者は3日ごとに錠剤を1回受け取る

21
00:01:18.188 --> 00:01:21.380
我々は特別な期間としてこれを考慮すること
ができます。

22
00:01:22.520 --> 00:01:25.320
さて、時間は、特定のイベントだ。

23
00:01:26.450 --> 00:01:31.660
このイベントは、行に依存しないか、行に従
属することができます。

24
00:01:31.660 --> 00:01:36.540
最初のケースでは、我々はちょうど1つの一
般的な瞬間から渡される時間を計算する

25
00:01:36.540 --> 00:01:37.540
すべてのデータ。

26
00:01:37.540 --> 00:01:40.420
たとえば、ここから千まで。

27
00:01:40.420 --> 00:01:44.970
ここで、すべてのサンプルは、1回のスケー
ルで互いの間で pairable
になります。

28
00:01:46.200 --> 00:01:49.318
特定のイベント以降の時間の2番目のバリア
ントとして、

29
00:01:49.318 --> 00:01:53.990
その日付は、我々はこれを計算しているサン
プルに依存します。

30
00:01:53.990 --> 00:01:56.705
例えば、お店で売り上げを予測するのであれ
ば、

31
00:01:56.705 --> 00:02:00.000
ロスマンの店の販売競争のように。

32
00:02:00.000 --> 00:02:05.370
我々は、最後の休日、週末から渡された日数
を追加することができます

33
00:02:05.370 --> 00:02:12.080
最後の販売キャンペーンから、または多分こ
れらのイベントに残された日数。

34
00:02:12.080 --> 00:02:16.690
したがって、これらの機能を追加した後、私
たちのデータフレームは、このようになりま
す。

35
00:02:17.860 --> 00:02:22.390
日付は明らかに日付であり、販売はこのタス
クのターゲットです。

36
00:02:23.400 --> 00:02:26.406
他の列は、生成された機能です。

37
00:02:26.406 --> 00:02:31.554
週の曜日機能は、週のどの日がこれであるか
を示します、daynumber 以来

38
00:02:31.554 --> 00:02:37.377
year 2014 は、2014の1月1
日から何日経過したかを示します。

39
00:02:37.377 --> 00:02:42.883
is_holiday は、この日が祝日で
あるかどうかを示すバイナリ機能で、

40
00:02:42.883 --> 00:02:49.001
days_ till_ 祝日は、最も近い
休日の前に何日が残っているかを示します。

41
00:02:49.001 --> 00:02:52.760
データに複数の datetime
列がある場合もあります。

42
00:02:52.760 --> 00:02:58.030
ここでのデータのほとんどは、別の機能から
1つのフィーチャを減算することです。

43
00:02:58.030 --> 00:03:03.390
またはおそらく生成された機能を減算,
一度我々が持っているように,
我々はちょうど議論している.

44
00:03:04.550 --> 00:03:09.420
0の依存イベントで渡される期間または時間
内の時間のモーメント。

45
00:03:09.420 --> 00:03:14.240
第3世代の1つの簡単な例は、チャーン予測
タスクで見つけることができます。

46
00:03:14.240 --> 00:03:17.850
基本的に解約予測は推定についてです

47
00:03:17.850 --> 00:03:20.200
顧客が解約する可能性。

48
00:03:21.520 --> 00:03:26.170
我々は、ユーザー登録日を差し引いて、ここ
で貴重な機能を受け取ることがあります

49
00:03:26.170 --> 00:03:29.940
彼のいくつかのアクションの日付から,
製品を購入するような, または

50
00:03:29.940 --> 00:03:32.120
顧客サービスへの呼び出し。

51
00:03:32.120 --> 00:03:35.000
我々は、このデータデータフレームにどのよ
うに動作するかを見ることができます。

52
00:03:35.000 --> 00:03:39.529
すべてのユーザーのために、我々は
last_purchase_date と
last_call_date
を知っている。

53
00:03:39.529 --> 00:03:44.980
ここでは、date_diff という名前
の新しい機能としてそれらの違いを追加しま
す。

54
00:03:44.980 --> 00:03:48.010
わかりやすくするために、この図を見てみま
しょう。

55
00:03:48.010 --> 00:03:52.350
すべてのユーザーにとって、我々は彼の
last_purchase_date
と彼の last_call_date
を持っている。

56
00:03:52.350 --> 00:03:55.570
したがって、我々は示す
date_diff
機能を追加することができます

57
00:03:55.570 --> 00:03:58.830
これらのイベントの間の日数。

58
00:03:58.830 --> 00:04:03.140
生成機能が日付時刻からの後であることに注
意してください, あなたは通常取得します

59
00:04:03.140 --> 00:04:06.550
年2000以降に経過した時刻のような数値
機能のいずれか

60
00:04:06.550 --> 00:04:10.520
またはカテゴリの機能は、曜日のような。

61
00:04:10.520 --> 00:04:15.070
そして、これらの機能は、今、それに応じて
扱われる必要がある

62
00:04:15.070 --> 00:04:18.610
必要な事前処理については先ほど説明しまし
た。

63
00:04:19.630 --> 00:04:22.630
次に、datetime
の機能生成について説明しました。

64
00:04:22.630 --> 00:04:26.582
座標のフィーチャ生成に移りましょう。

65
00:04:26.582 --> 00:04:30.340
我々は不動産価格を推定しようとしているこ
とを想像してみましょう。

66
00:04:30.340 --> 00:04:35.300
西オーストラリアのレンタル価格という名前
のデロイトの競争のように、

67
00:04:35.300 --> 00:04:38.440
またはズベルバンクのロシアの住宅市場の競
争。

68
00:04:39.610 --> 00:04:44.160
一般的に、マップ上の重要なポイントまでの
距離を計算することができます。

69
00:04:45.310 --> 00:04:46.660
この素晴らしい地図を保管してください。

70
00:04:46.660 --> 00:04:50.590
インフラストラクチャの建物に追加のデータ
がある場合は、

71
00:04:50.590 --> 00:04:55.640
距離病院で2番目に最寄りの店に機能距離と
して追加し、

72
00:04:55.640 --> 00:04:58.670
近所などで一番の学校へ。

73
00:04:59.680 --> 00:05:01.552
このようなデータがない場合は、

74
00:05:01.552 --> 00:05:06.480
あなたの訓練を受けたテストデータからマッ
プ上の興味深い点を抽出することができます
。

75
00:05:06.480 --> 00:05:10.646
たとえば、正方形に新しいマップを作成した
り、グリッドを使用したり、

76
00:05:10.646 --> 00:05:14.414
各広場の中で、最も高価なフラットを見つけ
ると、

77
00:05:14.414 --> 00:05:19.170
この正方形の他のすべてのオブジェクトにつ
いて、そのフラットに距離を追加します。

78
00:05:19.170 --> 00:05:23.085
または、データポイントをクラスタに整理し
たり、

79
00:05:23.085 --> 00:05:27.010
その後、クラスタの中心を重要なポイントと
して使用します。

80
00:05:28.050 --> 00:05:29.460
または、別の方法。

81
00:05:29.460 --> 00:05:34.236
あなたは非常に古い建物と地域のようないく
つかの特別な領域を見つけることができます

82
00:05:34.236 --> 00:05:35.940
この1つに距離を追加します。

83
00:05:37.290 --> 00:05:42.500
座標を使用するもう1つの主要なアプローチ
は、集計統計を計算することです。

84
00:05:42.500 --> 00:05:44.880
周辺のオブジェクト。

85
00:05:44.880 --> 00:05:48.180
これは、この特定のポイントを回避すること
ができますの数を含むことができる

86
00:05:48.180 --> 00:05:51.530
その後、領域または極性として解釈すること
ができます。

87
00:05:52.650 --> 00:05:55.053
または我々は、平均不動産価格を追加するこ
とができます

88
00:05:55.053 --> 00:06:00.050
どのように選択したポイントの周りの高価な
領域を示します。

89
00:06:01.460 --> 00:06:03.110
両方の距離と

90
00:06:03.110 --> 00:06:07.580
集計統計は、多くの場合、座標を持つタスク
で役立ちます。

91
00:06:08.780 --> 00:06:13.342
あなたは座標について知る必要があるもう一
つのトリックは、あなたが決定を訓練する場
合

92
00:06:13.342 --> 00:06:18.670
それらからの木は、わずかに回転した座標を
追加することができます新機能です。

93
00:06:18.670 --> 00:06:22.930
これは、モデルがマップ上でより正確な選択
を行うのに役立ちます。

94
00:06:24.350 --> 00:06:28.320
それは我々が作るべき正確な回転を知るのは
難しいことができますので、

95
00:06:28.320 --> 00:06:34.040
我々は、45または22.5 度にすべての
回転を追加することができます。

96
00:06:35.220 --> 00:06:38.510
次に、相対的な価格予測の例を見てみましょ
う。

97
00:06:39.990 --> 00:06:43.550
ここで通りは2つの部分の区域を分けている
。

98
00:06:43.550 --> 00:06:48.570
通りの上の高価格の地区、およびそれの下の
低価格の地区。

99
00:06:48.570 --> 00:06:55.350
通りが少し回転すれば、木はここに多くのス
ペースを作ることを試みる。

100
00:06:55.350 --> 00:07:00.582
しかし、我々はこれらの2つの地区が分割す
ることができる新しい座標を追加する場合

101
00:07:00.582 --> 00:07:05.670
単一の分割によって、これは非常に再建プロ
セスを促進する。

102
00:07:06.710 --> 00:07:10.750
偉大な、我々は最も頻繁に使用される方法を
要約

103
00:07:10.750 --> 00:07:13.802
datetime
と座標からの将来の生成。

104
00:07:13.802 --> 00:07:18.930
datetime の場合、これらは周期性
を適用し、渡された時間で計算されます

105
00:07:18.930 --> 00:07:24.550
特定のイベント、および2つの
datetime
機能間のエンジンの違いから。

106
00:07:25.680 --> 00:07:29.818
座標のために、私達はからの興味深いサンプ
ルの抽出をリコールするべきである

107
00:07:29.818 --> 00:07:35.070
訓練されたテストデータ、追加データからの
場所を使用して、距離を計算する

108
00:07:35.070 --> 00:07:40.520
クラスタの中心となり、周辺地域の集計統計
を追加します。

109
00:07:42.380 --> 00:07:47.660
datetime と座標を効果的に処理す
る方法を知っているだけでなく、数値と

110
00:07:47.660 --> 00:07:52.750
カテゴリ機能は、あなたのスコアを向上させ
るために信頼性の高い方法を提供します。

111
00:07:52.750 --> 00:07:57.340
そして、あなたは、ソリューションの特定の
部分を考案するために

112
00:07:57.340 --> 00:08:00.401
多くの場合、非常にトップスコアを打つため
に必要。

113
00:08:00.401 --> 00:08:10.401
音

