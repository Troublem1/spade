1
00:00:03.813 --> 00:00:08.290
多くの場合、データの欠落値に対処する必要
があります。

2
00:00:08.290 --> 00:00:14.982
彼らは、数字、空の文字列、またはマイナス
999のような外れ値のように見えるかもし
れません。

3
00:00:14.982 --> 00:00:18.583
時々、彼らは自分で有用な情報を含めること
ができます

4
00:00:18.583 --> 00:00:22.840
ここで発生する価値の欠落の理由は何だった
ような?

5
00:00:22.840 --> 00:00:24.320
効果的にそれらを使用する方法?

6
00:00:24.320 --> 00:00:26.640
どのようにそれらから新しい機能をエンジニ
アに?

7
00:00:26.640 --> 00:00:28.430
このビデオのトピックを説明します。

8
00:00:29.520 --> 00:00:33.080
不足値にはどのような情報が含まれる可能性
がありますか。

9
00:00:33.080 --> 00:00:34.840
どのように見えることができますか?

10
00:00:34.840 --> 00:00:38.050
のは、スプリングフィールドの競争の中で欠
落している値を見てみましょう。

11
00:00:39.870 --> 00:00:42.382
これは、サンプルと機能の指標です。

12
00:00:42.382 --> 00:00:47.858
人々は、主に各機能を見直し、各列の欠落値
を発見した。

13
00:00:47.858 --> 00:00:55.290
この最新の値は、数値、空の文字列、マイナ
ス1、99などではありません。

14
00:00:55.290 --> 00:01:01.345
例えば、どのように我々は、-1 が不足し
ている値になることを発見することができま
すか?

15
00:01:01.345 --> 00:01:03.849
我々は、ヒストグラムを描くことができると

16
00:01:03.849 --> 00:01:09.980
この変数は、0 ~ 1
の間に一様分布を持つことを確認します。

17
00:01:09.980 --> 00:01:13.870
そして、それは-1
の値の小さなピークを持っていること。

18
00:01:13.870 --> 00:01:20.433
そこで番号がない場合、我々は彼らが-1 
で置き換えられたと仮定することができます
。

19
00:01:20.433 --> 00:01:25.020
または、フィーチャ分布プロットは2番目の
図のようになります。

20
00:01:26.220 --> 00:01:29.050
x 軸にはロックスケールがあることに注意
してください。

21
00:01:29.050 --> 00:01:33.641
この例では、数字はおそらく、機能の平均値
によって少なかった。

22
00:01:33.641 --> 00:01:37.829
このロジックを簡単に一般化して、他のケー
スに適用することができます。

23
00:01:39.190 --> 00:01:44.950
さて、この例では、我々はこれを学んだ、不
足している値は、私たちから隠すことができ
ます。

24
00:01:44.950 --> 00:01:49.290
と隠さ私はいくつかの他の値ではなく、番号
の横に置き換えを意味します。

25
00:01:50.520 --> 00:01:53.940
大きい、行方不明の価値輸入について話して
みましょう。

26
00:01:53.940 --> 00:01:56.370
一番多い例はまず、

27
00:01:56.370 --> 00:02:00.912
固定値の範囲外の値を持つ数値ではなく置換
します。

28
00:02:00.912 --> 00:02:04.740
第二に、平均または中央値ではない番号を置
き換える。

29
00:02:04.740 --> 00:02:07.720
第三に、何らかの価値を再構築しようとする
。

30
00:02:08.980 --> 00:02:11.680
最初のメソッドは、それが与える方法で有用
である

31
00:02:11.680 --> 00:02:15.910
3つの可能性を別のカテゴリに欠損値を取る
。

32
00:02:15.910 --> 00:02:21.540
この欠点は、線形ネットワークのパフォーマ
ンスが低下する可能性があることです。

33
00:02:22.632 --> 00:02:26.740
2番目の方法は、通常、単純な線形モデルと
ニューラルネットワークに有益です。

34
00:02:26.740 --> 00:02:31.520
しかし、再び木のためにそれが困難な値を欠
落していたオブジェクトを選択することがで
きます

35
00:02:31.520 --> 00:02:32.480
そもそもですね。

36
00:02:33.740 --> 00:02:37.070
とりあえず特徴値の再構築を続けてみて、

37
00:02:37.070 --> 00:02:39.120
一瞬、機能生成に変わります。

38
00:02:40.410 --> 00:02:44.660
私達がちょうど論議した心配は新しい特徴を
加えることによって演説することができる

39
00:02:44.660 --> 00:02:49.350
この機能の値が不足している行を示す
isnull。

40
00:02:50.490 --> 00:02:52.840
これは木との問題を解決できる

41
00:02:52.840 --> 00:02:56.300
平均または中央値を計算しながらニューラル
ネットワーク。

42
00:02:56.300 --> 00:03:00.840
しかし、この欠点は、データセット内の列数
を2倍にすることです。

43
00:03:02.140 --> 00:03:05.160
今戻って行方不明の値の輸入方法に。

44
00:03:05.160 --> 00:03:06.510
3つ目は、

45
00:03:06.510 --> 00:03:11.680
我々はここで議論する最後の1つは、可能で
あれば、各値を再構築することです。

46
00:03:11.680 --> 00:03:16.900
このような可能性の1つの例では、時系列の
値が欠落しています。

47
00:03:16.900 --> 00:03:19.970
例えば、我々は毎日の温度を持つことができ
ます

48
00:03:19.970 --> 00:03:24.950
月が数ヶ月の半ばにいくつかの値が欠落して
います。

49
00:03:24.950 --> 00:03:29.270
まあもちろん、我々は近くの観測を使用して
それらを近似することができます。

50
00:03:29.270 --> 00:03:33.880
しかし、明らかに、このような機会はめった
にありません。

51
00:03:33.880 --> 00:03:38.450
一般的なシナリオでは、データセットの行は
独立しています。

52
00:03:38.450 --> 00:03:42.430
そして、我々は通常、それらを再構築するた
めの適切なロジックを見つけることはありま
せん。

53
00:03:44.030 --> 00:03:49.075
偉大な、我々はすでに我々は新しい機能を構
築することができたことを学んだこの瞬間に
、

54
00:03:49.075 --> 00:03:53.600
isnull 番号を含まない行を示す。

55
00:03:55.110 --> 00:03:58.529
私たちが知っておくべき機能の生成に関する
他の重要な瞬間は何ですか?

56
00:03:59.550 --> 00:04:02.800
よく1つの一般的な懸念がある

57
00:04:02.800 --> 00:04:06.840
欠損値を持つものから新しいフィーチャを生
成する。

58
00:04:06.840 --> 00:04:10.780
つまり、我々はこれを行う場合、我々は非常
に注意する必要があります

59
00:04:10.780 --> 00:04:13.480
機能の生成前に欠損値を置き換える。

60
00:04:13.480 --> 00:04:19.900
これを説明するために、2つの機能を備えた
1年のデータセットを想像してみましょう。

61
00:04:19.900 --> 00:04:24.090
値が不足していた昼間の特徴と温度。

62
00:04:24.090 --> 00:04:26.320
我々は、図にこのすべてを見ることができま
す。

63
00:04:28.040 --> 00:04:32.960
今、我々はいくつかの値を持つ欠落した値を
埋める, 例えば、メジアン.

64
00:04:32.960 --> 00:04:39.030
あなたは全体の年間の中央値以上のデータを
持っている場合、おそらくゼロの近くになり
ますので、

65
00:04:39.030 --> 00:04:40.680
そのように見えるはずです。

66
00:04:40.680 --> 00:04:44.980
今、私たちは、今日の温度との違いのような
機能を追加したい

67
00:04:44.980 --> 00:04:46.770
昨日、こうしましょう。

68
00:04:48.210 --> 00:04:49.290
我々が見ることができるように、

69
00:04:49.290 --> 00:04:53.980
不足している値の近くにこの違いは、通常、
異常に巨大になります。

70
00:04:53.980 --> 00:04:56.890
そして、これは私たちのモデルを誤解するこ
とができます。

71
00:04:56.890 --> 00:05:01.816
しかし、ちょっと、我々はすでに、我々はこ
こで欠落値を近似できることを知っている

72
00:05:01.816 --> 00:05:04.780
点によって誤差を補間することによって、素
晴らしい。

73
00:05:04.780 --> 00:05:09.250
しかし、残念ながら、我々は通常、十分な時
間をここに注意する必要はありません。

74
00:05:09.250 --> 00:05:10.726
さらに重要なことは

75
00:05:10.726 --> 00:05:16.050
これらの問題は、このような特定の解決策を
思い付くことができない場合に発生する可能
性があります。

76
00:05:17.210 --> 00:05:20.270
欠落している値のインポートの別の例を確認
してみましょう。

77
00:05:20.270 --> 00:05:22.830
これは、実質的に後で議論される

78
00:05:22.830 --> 00:05:25.050
高度な機能 [聞き取れない]
トピックで。

79
00:05:26.080 --> 00:05:29.650
ここでは、独立した行を持つデータセットが
あります。

80
00:05:29.650 --> 00:05:33.978
また、カテゴリ機能を数値機能でエンコード
するとします。

81
00:05:33.978 --> 00:05:39.020
我々は、数値機能の平均値を計算することを
達成するために

82
00:05:39.020 --> 00:05:42.930
すべてのカテゴリ、およびこれらの平均値を
持つカテゴリを置き換えます。

83
00:05:44.000 --> 00:05:48.200
数値フィーチャの数字ではなく、

84
00:05:48.200 --> 00:05:52.790
-999
のような機能範囲外のいくつかの値を持つ。

85
00:05:54.200 --> 00:05:58.726
我々が見ることができるように、我々は彼ら
に近い-999
を行うことになりますすべての値。

86
00:05:58.726 --> 00:06:03.531
そして、より多くの行の特定のカテゴリに対
応して行方不明になります

87
00:06:03.531 --> 00:06:04.310
値。

88
00:06:04.310 --> 00:06:08.925
より近い平均値は-999 になります。

89
00:06:08.925 --> 00:06:14.860
フィーチャの平均値または中央値が欠落して
いる場合は、同じことが言えます。

90
00:06:14.860 --> 00:06:18.617
不足している値の輸入のこの種は間違いなく
我々は機能を台無しにすることができます

91
00:06:18.617 --> 00:06:20.420
が構築されます。

92
00:06:20.420 --> 00:06:23.750
この特定のケースを処理する方法は、単に

93
00:06:23.750 --> 00:06:27.510
各カテゴリの平均を計算するときに、欠落値
を無視します。

94
00:06:28.630 --> 00:06:32.480
再び私は、これらの2つの例のアイデアを繰
り返すことができます。

95
00:06:33.560 --> 00:06:38.190
あなたが新しい生成したい場合は、初期なし
の輸入に非常に注意する必要があります

96
00:06:38.190 --> 00:06:39.790
機能。

97
00:06:39.790 --> 00:06:42.570
値の欠落についてもう1つ興味深い点があり
ます。

98
00:06:43.823 --> 00:06:46.476
[聞き取れない] ブーストは、数字の多く
を処理することができます

99
00:06:46.476 --> 00:06:50.090
時にはこのアプローチを使用して大幅にスコ
アを変更できます。

100
00:06:51.220 --> 00:06:53.320
私達が論議した共通のアプローチのほかに、

101
00:06:53.320 --> 00:06:56.400
外れ値を欠品として扱うこともあります。

102
00:06:56.400 --> 00:07:01.293
例えば、我々は曲といくつかの簡単な分類タ
スクを持っている場合

103
00:07:01.293 --> 00:07:06.932
古代ローマ、または多分年2025の前に構
成されると考えられている。

104
00:07:06.932 --> 00:07:10.249
これらの外れ値を欠品として扱うことができ
ます。

105
00:07:11.280 --> 00:07:12.980
カテゴリ機能がある場合は、

106
00:07:12.980 --> 00:07:16.640
場合によっては、不足している値を変更する
ことが有益です。

107
00:07:16.640 --> 00:07:21.970
テストデータに存在するが、列車のデータに
存在しないカテゴリ。

108
00:07:21.970 --> 00:07:26.010
そうするための意図は、持っていなかったモ
デルが実際に訴える

109
00:07:26.010 --> 00:07:30.148
列車のデータのそのカテゴリは、最終的には
ランダムに処理されます。

110
00:07:30.148 --> 00:07:35.180
こことカテゴリの機能のヘルプをすることが
できます。

111
00:07:35.180 --> 00:07:40.460
我々はすでに我々のコースで説明したように
、我々はその周波数にカテゴリを変更するこ
とができます

112
00:07:40.460 --> 00:07:44.560
そしてこうしてそれにカテゴリは頻度に基づ
いて前にあった。

113
00:07:45.740 --> 00:07:49.010
スライドの例を見てみましょう。

114
00:07:49.010 --> 00:07:53.316
そこには、カテゴリの機能から参照してくだ
さい、彼らは列車に表示されません。

115
00:07:53.316 --> 00:07:56.310
を示す新しい機能を生成してみましょう

116
00:07:56.310 --> 00:07:58.640
データ内で発生した場所の数。

117
00:07:59.940 --> 00:08:03.040
この機能を
categorical_encoded
に名前を指定します。

118
00:08:03.040 --> 00:08:07.608
値 A には、列車とテストの両方で6つの
オカレンスがあり、

119
00:08:07.608 --> 00:08:12.684
A に関連する新しい機能の値は、6に等し
くなります。

120
00:08:12.684 --> 00:08:16.480
値 B、D、または C
についても同じ動作をします。

121
00:08:16.480 --> 00:08:22.000
しかし、現在、さまざまな D と C に
関連する新しい機能は、お互いに等しくなり
ます。

122
00:08:22.000 --> 00:08:25.960
との間のターゲットと数の間にいくつかの依
存性がある場合

123
00:08:25.960 --> 00:08:30.090
各カテゴリは、我々のモデルが正常に可視化
することができます。

124
00:08:31.260 --> 00:08:35.060
このビデオを締結するには、letツエs
の概要について説明した要点を示します。

125
00:08:36.510 --> 00:08:41.260
数字ではなく埋める方法の選択は、状況によ
って異なります。

126
00:08:41.260 --> 00:08:43.760
場合によっては、欠損値を再構築できます。

127
00:08:43.760 --> 00:08:49.020
しかし、通常、それは外の値でそれらを交換
する方が簡単です

128
00:08:49.020 --> 00:08:53.520
-999 のような機能の範囲、または平均
または中央値に置き換えます。

129
00:08:54.890 --> 00:08:59.930
また、欠落している値は、すでに主催者が何
かに置き換えることができます。

130
00:09:01.520 --> 00:09:05.940
この場合は、値が欠落している正確な行を知
る必要がある場合

131
00:09:05.940 --> 00:09:09.890
これは、ヒストグラムを参照して調べること
ができます。

132
00:09:09.890 --> 00:09:14.497
さらに、モデルはバイナリ機能
isnull を使用してその結果を改善す
ることができます

133
00:09:14.497 --> 00:09:17.210
値が欠落しているロールを示します。

134
00:09:18.350 --> 00:09:22.680
一般に、フィーチャーの生成前に欠損値を置
き換えないでください。

135
00:09:22.680 --> 00:09:26.530
それは機能の有用性を減らすことができるの
で。

136
00:09:26.530 --> 00:09:30.400
そして最後に、Xgboost
は直接番号を扱うことができない、

137
00:09:30.400 --> 00:09:33.330
これは、時には良いのスコアを変更すること
ができます。

138
00:09:34.620 --> 00:09:37.569
あなたが私たちの議論から派生した知識を使
用して、

139
00:09:37.569 --> 00:09:40.275
これで、不足している値を識別できるように
なります。

140
00:09:40.275 --> 00:09:42.910
それらを処理する主なメソッドを説明し、

141
00:09:42.910 --> 00:09:46.798
次の計算でエッジを取得するには、この知識
を適用します。

142
00:09:46.798 --> 00:09:50.864
でこれらのメソッドを試してください

143
00:09:50.864 --> 00:09:55.887
さまざまなシナリオと

144
00:09:55.887 --> 00:10:01.874
確かに、あなたは成功します。

