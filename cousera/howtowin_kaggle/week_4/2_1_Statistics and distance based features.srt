1
00:00:02.670 --> 00:00:05.630
ねえ皆さん。

2
00:00:05.630 --> 00:00:10.770
このビデオは、次の高度な機能工学技術に捧
げられています。

3
00:00:10.770 --> 00:00:14.400
1つのフィーチャのさまざまな統計をグルー
プ化して計算する

4
00:00:14.400 --> 00:00:19.425
別の、特定のポイントの近傍解析から派生し
た機能。

5
00:00:19.425 --> 00:00:21.660
それを少しはっきりさせるために、

6
00:00:21.660 --> 00:00:24.000
簡単な例を考えてみましょう。

7
00:00:24.000 --> 00:00:27.590
ここでは、いくつかの CTR
タスクのためのデータの塊があります。

8
00:00:27.590 --> 00:00:31.735
ターゲット変数を忘れて、人間の特徴に焦点
を当てるようにしましょう。

9
00:00:31.735 --> 00:00:35.865
すなわち、User_ID、ユーザーの一意
の識別子、

10
00:00:35.865 --> 00:00:40.120
Page_ID、訪問したページのユーザー
の識別子、

11
00:00:40.120 --> 00:00:43.890
Ad_price、広告の商品価格、

12
00:00:43.890 --> 00:00:49.645
Ad_position、web
ページ上の広告の相対位置を表示します。

13
00:00:49.645 --> 00:00:53.310
この問題を解決する最も簡単な方法は、ラベ
ルを付けることです

14
00:00:53.310 --> 00:00:57.450
そして、Ad_position
を呼び出して、いくつかの分類子を養う。

15
00:00:57.450 --> 00:01:00.480
それはに取ることができる非常に良い分類さ
れる

16
00:01:00.480 --> 00:01:04.395
変数間のすべての非表示の関係を記述します
。

17
00:01:04.395 --> 00:01:06.720
でも、どんなに良いことがあっても、

18
00:01:06.720 --> 00:01:10.670
それでも、すべてのデータポイントを個別に
扱います。

19
00:01:10.670 --> 00:01:13.855
そして、ここでは、機能エンジニアリングを
適用することができます。

20
00:01:13.855 --> 00:01:16.460
我々は、広告を意味することができます

21
00:01:16.460 --> 00:01:20.580
ページ上の最低価格は、注目のほとんどをキ
ャッチします。

22
00:01:20.580 --> 00:01:24.450
ページ上の広告の残りの部分は非常に魅力的
ではありません。

23
00:01:24.450 --> 00:01:29.165
このような含意に関連する機能を計算するの
は非常に簡単です。

24
00:01:29.165 --> 00:01:34.930
我々は、広告ごとにすべてのユーザーとペー
ジの最低価格と最高値を追加することができ
ます。

25
00:01:34.930 --> 00:01:40.115
最低価格の広告の位置は、このような場合に
も使用することができます。

26
00:01:40.115 --> 00:01:44.753
ここでは、有料広告で統計機能を実装する方
法の1つです。

27
00:01:44.753 --> 00:01:48.615
データフレーム df
にデータが格納されている場合は、

28
00:01:48.615 --> 00:01:55.550
このような groupby メソッドを呼
び出して、最大値と最小価格を取得します。

29
00:01:55.550 --> 00:01:59.160
次に、このオブジェクトを gb
変数に格納し、

30
00:01:59.160 --> 00:02:04.627
そして、データフレームの df
に戻ってそれを結合します。そうなんです。

31
00:02:04.627 --> 00:02:09.325
この時点でやめてはいけないことを強調した
いと思います。

32
00:02:09.325 --> 00:02:12.210
他の便利な機能を追加することはできません

33
00:02:12.210 --> 00:02:16.200
必ずしもユーザーとページごとに計算されま
す。

34
00:02:16.200 --> 00:02:19.410
ユーザーが訪問したページの数である可能性
があります。

35
00:02:19.410 --> 00:02:23.455
指定されたセッション中にユーザーが訪問し
たページ数

36
00:02:23.455 --> 00:02:26.280
そして最も訪問されたページの ID、

37
00:02:26.280 --> 00:02:28.965
どのように多くのユーザーがそのページを訪
問している

38
00:02:28.965 --> 00:02:31.670
そして、多くの、より多くの機能。

39
00:02:31.670 --> 00:02:35.215
主なアイデアは、新しい情報を紹介すること
です。

40
00:02:35.215 --> 00:02:40.210
その手段によって、我々は大幅にモデルの品
質を高めることができます。

41
00:02:40.210 --> 00:02:44.090
しかし、groupby を使用する機能が
ない場合はどうなりますか?

42
00:02:44.090 --> 00:02:45.960
まあ、このような場合には、

43
00:02:45.960 --> 00:02:50.535
グループ化操作を、最も近い近傍の検索に置
き換えることができます。

44
00:02:50.535 --> 00:02:56.370
一方で、有用な情報を実装して収集するのは
非常に困難です。

45
00:02:56.370 --> 00:02:59.455
一方で、方法はより適用範囲が広い。

46
00:02:59.455 --> 00:03:05.370
我々は、関連する近傍またはメトリックのサ
イズのようなものを微調整することができま
す。

47
00:03:05.370 --> 00:03:07.740
最も一般的で自然な例

48
00:03:07.740 --> 00:03:12.050
近所の分析は、目的価格から発生します。

49
00:03:12.050 --> 00:03:14.970
賃貸料を予測する必要があることを想像しな
さい。

50
00:03:14.970 --> 00:03:19.150
おそらく、床面積のようないくつかの特性を
持っているだろう

51
00:03:19.150 --> 00:03:22.050
部屋数、バス停の有無。

52
00:03:22.050 --> 00:03:26.665
しかし、あなたは本当に良いモデルを作成す
るためにそれ以上のものが必要です。

53
00:03:26.665 --> 00:03:30.090
それは他の家の数であることができる

54
00:03:30.090 --> 00:03:35.370
500メートル、1000メートルのような
別の地域、

55
00:03:35.370 --> 00:03:41.080
または1500メートル、またはそのような
地域の平方メートルあたりの平均価格、

56
00:03:41.080 --> 00:03:43.140
または学校の数、

57
00:03:43.140 --> 00:03:47.190
そのような近隣のスーパーマーケット、およ
び駐車場。

58
00:03:47.190 --> 00:03:50.835
興味の最も近い目的への間隔

59
00:03:50.835 --> 00:03:54.950
地下鉄の駅やジムのようにも使用することが
できます。

60
00:03:54.950 --> 00:03:56.835
あなたは考えを持っていると思います。

61
00:03:56.835 --> 00:04:00.705
例では、我々は非常に単純なケースを使用し
てきた

62
00:04:00.705 --> 00:04:04.980
地域が地理的空間で計算された場所。

63
00:04:04.980 --> 00:04:08.040
しかし、このメソッドを適用することを恐れ
てはいけない

64
00:04:08.040 --> 00:04:11.710
いくつかの抽象的な、あるいは匿名の特徴空
間。

65
00:04:11.710 --> 00:04:14.055
それはまだ非常に有用である可能性がありま
す。

66
00:04:14.055 --> 00:04:18.350
私のチームと私は春の葉の競争では、このメ
ソッドを使用します。

67
00:04:18.350 --> 00:04:22.910
さらに、我々は監督のファッションでそれを
やった。

68
00:04:22.910 --> 00:04:24.405
ここで我々はそれを行っている方法です。

69
00:04:24.405 --> 00:04:28.260
まず、すべての変数に平均符号化を適用した
。

70
00:04:28.260 --> 00:04:32.940
そうすることで、我々は均質な特徴空間を作
り、

71
00:04:32.940 --> 00:04:38.325
スケーリングと各特定の機能の重要性を心配
していませんでした。

72
00:04:38.325 --> 00:04:44.595
その後、我々はブレイ-カーティスメトリッ
クと2000最寄りの隣人を計算した。

73
00:04:44.595 --> 00:04:48.810
その後、我々は、から様々な機能を評価

74
00:04:48.810 --> 00:04:53.740
これらの隣人は、最も近い 5, 10,
15, 500 の平均目標のように、

75
00:04:53.740 --> 00:04:59.540
2000隣人、10の最も近い隣人への平均
距離、

76
00:04:59.540 --> 00:05:03.713
ターゲット1を持つ10の最も近い隣人への
平均距離、

77
00:05:03.713 --> 00:05:08.240
とターゲット0との10の最も近い隣人への
平均距離、

78
00:05:08.240 --> 00:05:10.845
そして、それは素晴らしい仕事をした。

79
00:05:10.845 --> 00:05:16.125
結論として、私はあなたの主なアイデアを受
け入れることを望む

80
00:05:16.125 --> 00:05:20.085
groupby
と最も近い近傍メソッドの両方

81
00:05:20.085 --> 00:05:24.935
そして、あなたは実際にそれらを適用するこ
とができるでしょう。

82
00:05:24.935 --> 00:05:28.510
ご注意をありがとうございました。

