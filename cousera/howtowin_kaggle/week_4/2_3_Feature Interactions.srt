1
00:00:02.990 --> 00:00:05.183
ねえ皆さん。

2
00:00:05.183 --> 00:00:08.535
このビデオの主なトピックは、機能の相互作
用です。

3
00:00:08.535 --> 00:00:12.040
あなたはそれらを構築し、問題解決に使用す
る方法を学びます。

4
00:00:12.040 --> 00:00:16.405
さらに、デシジョンツリーからのフィーチャ
抽出についても説明します。

5
00:00:16.405 --> 00:00:18.100
例から始めましょう。

6
00:00:18.100 --> 00:00:20.160
我々は予測するモデルを構築していると仮定

7
00:00:20.160 --> 00:00:23.245
ウェブサイトに表示する最高の広告バナー。

8
00:00:23.245 --> 00:00:27.760
利用可能な機能の中で、我々が集中する2つ
のカテゴリのものがあります。

9
00:00:27.760 --> 00:00:30.810
広告バナー自体のカテゴリと

10
00:00:30.810 --> 00:00:34.150
バナーが表示されるサイトのカテゴリ。

11
00:00:34.150 --> 00:00:37.603
確かに、我々は2つの独立したものとして機
能を使用することができます

12
00:00:37.603 --> 00:00:41.525
しかし、本当に重要な機能は、実際にそれら
の組み合わせです。

13
00:00:41.525 --> 00:00:43.770
我々は、明示的に組み合わせを構築すること
ができます

14
00:00:43.770 --> 00:00:47.015
我々の知識をモデルに取り入れるために

15
00:00:47.015 --> 00:00:52.195
組み合わせを表す ad_site という
名前の新しい機能を構築してみましょう。

16
00:00:52.195 --> 00:00:54.551
これは、古いものとしてカテゴリになります
,

17
00:00:54.551 --> 00:01:00.270
しかし、その値のセットは、2つの元の値の
すべての可能な組み合わせになります。

18
00:01:00.270 --> 00:01:01.905
技術的な観点から、

19
00:01:01.905 --> 00:01:04.785
このようなインタラクションを構築するには
2つの方法があります。

20
00:01:04.785 --> 00:01:07.170
簡単な例を見てみましょう。

21
00:01:07.170 --> 00:01:08.700
私達の最初特徴を考慮しなさい、

22
00:01:08.700 --> 00:01:10.610
f1 は、a または B
の値を持っています。

23
00:01:10.610 --> 00:01:13.714
別の機能 f2 には、X または Y
または Z の値があり、

24
00:01:13.714 --> 00:01:17.870
データセットは4つのデータポイントで構成
されています。

25
00:01:17.870 --> 00:01:21.810
最初の方法は、f1 と f2
のテキスト値を連結することです。

26
00:01:21.810 --> 00:01:25.710
、結果を新しいカテゴリ機能 f_join
として使用します。

27
00:01:25.710 --> 00:01:28.520
我々はそれに応じて OneHot
を適用することができます。

28
00:01:28.520 --> 00:01:30.840
2番目のアプローチは2つのステップから成
ります。

29
00:01:30.840 --> 00:01:35.025
まず、OneHot を適用し、f1 と
f2 の機能に接続します。

30
00:01:35.025 --> 00:01:38.940
次に、各列を乗算して新しいメトリックを構
築します。

31
00:01:38.940 --> 00:01:43.390
f2
エンコードされたメトリックから各列への
f1 エンコードメトリック。

32
00:01:43.390 --> 00:01:46.068
これは、両方のメソッドの結果は何もなかっ
た

33
00:01:46.068 --> 00:01:49.410
実質的に同じ新機能の表現。

34
00:01:49.410 --> 00:01:51.075
上記の例では、

35
00:01:51.075 --> 00:01:54.570
我々は、カテゴリの機能間の相互作用として
考慮することができます

36
00:01:54.570 --> 00:01:58.060
しかし、同様のアイデアは、実際の価値のあ
る機能に適用することができます。

37
00:01:58.060 --> 00:02:01.230
たとえば、f1 と f2
の2つの実際の評価機能を持つ

38
00:02:01.230 --> 00:02:07.375
それらの間の相互作用は f1 および
f2 の乗算によって得ることができる。

39
00:02:07.375 --> 00:02:11.035
実際には、乗算演算のみを使用するように制
限されていません。

40
00:02:11.035 --> 00:02:14.070
sum のような2つの引数をとる関数

41
00:02:14.070 --> 00:02:16.735
違い、または分割は大丈夫です。

42
00:02:16.735 --> 00:02:19.320
次の変換が大幅に拡大

43
00:02:19.320 --> 00:02:22.695
特徴空間と学習が容易になります,

44
00:02:22.695 --> 00:02:26.205
しかし、それがまたは頻繁に簡単すぎること
に留意してください。

45
00:02:26.205 --> 00:02:29.610
このような3つの方法のアルゴリズムについ
ては、強調する必要があります

46
00:02:29.610 --> 00:02:32.280
ランダムフォレストまたはグラデーションブ
ーストデシジョンツリー

47
00:02:32.280 --> 00:02:35.530
このような依存関係を抽出するのは困難です
。

48
00:02:35.530 --> 00:02:40.265
そのため、バッファ変換は3つのベースのメ
ソッドに対して非常に効率的です。

49
00:02:40.265 --> 00:02:42.755
今、実践的な詳細を議論しましょう。

50
00:02:42.755 --> 00:02:47.520
ここで賢明な未来の世代が大幅に機能の数を
増やすアプローチ。

51
00:02:47.520 --> 00:02:49.190
本来の特徴があれば、

52
00:02:49.190 --> 00:02:51.150
n 四角になります。

53
00:02:51.150 --> 00:02:55.240
いくつかの種類の相互作用が使用されている
場合、さらに多くの機能になります。

54
00:02:55.240 --> 00:02:57.550
これをモデレートする方法は2つありますが
、

55
00:02:57.550 --> 00:03:01.100
フィーチャの選択または次元の縮小を行いま
す。

56
00:03:01.100 --> 00:03:03.060
私は以来、選択を行うことを好む

57
00:03:03.060 --> 00:03:05.615
すべてが少数の相互作用だけ頻繁に

58
00:03:05.615 --> 00:03:09.000
機能のすべての組み合わせと同じ品質を実現
します。

59
00:03:09.000 --> 00:03:10.830
相互作用の種類ごとに、

60
00:03:10.830 --> 00:03:13.555
私はすべての区分的特徴の相互作用を構築す
る。

61
00:03:13.555 --> 00:03:18.150
それらの上のランダムな森林を特色にし、い
くつかの最重要機能を選択します。

62
00:03:18.150 --> 00:03:22.265
各タイプの結果として得られるフィーチャの
数が比較的少ないためです。

63
00:03:22.265 --> 00:03:25.800
元の機能と一緒にそれらを結合することは可
能であり、

64
00:03:25.800 --> 00:03:29.975
あらゆる機械学習アルゴリズムのための入力
として通常使用方法によってあるために使用
しなさい。

65
00:03:29.975 --> 00:03:34.660
ビデオの中で, 我々は2番目の順序の相互
作用を構築する方法を検討している.

66
00:03:34.660 --> 00:03:38.750
しかし、同様に throned
注文以上を生成することができます。

67
00:03:38.750 --> 00:03:42.680
特徴の数が順序と急速に育つという事実のた
めに、

68
00:03:42.680 --> 00:03:45.225
彼らとの仕事が難しくなってきました。

69
00:03:45.225 --> 00:03:49.440
従って高い順序の方向は頻繁に半手動で組み
立てられる。

70
00:03:49.440 --> 00:03:52.165
そして、これはいくつかの方法で芸術です。

71
00:03:52.165 --> 00:03:54.690
さらに、私は方法についての話をしたいと思
います

72
00:03:54.690 --> 00:03:57.880
デシジョンツリーからカテゴリ機能を構築し
ます。

73
00:03:57.880 --> 00:03:59.840
デシジョンツリーを見てみましょう。

74
00:03:59.840 --> 00:04:03.475
各リーフをバイナリフィーチャにマップして
みましょう。

75
00:04:03.475 --> 00:04:09.215
オブジェクトのリーフのインデックスは、新
しいカテゴリ機能の値として使用できます。

76
00:04:09.215 --> 00:04:12.565
1つのツリーではなく、それらのアンサンブ
ルを使用する場合。

77
00:04:12.565 --> 00:04:14.260
たとえば、ランダムなフォレスト、

78
00:04:14.260 --> 00:04:18.070
その後、このような操作は、各エントリに適
用することができます。

79
00:04:18.070 --> 00:04:22.270
これは、高い順序の相互作用を抽出する強力
な方法です。

80
00:04:22.270 --> 00:04:24.895
この手法は実装が非常に簡単です。

81
00:04:24.895 --> 00:04:27.970
sklearn
ライブラリからのツリーベースのプードル

82
00:04:27.970 --> 00:04:30.190
としてかかる適用方法

83
00:04:30.190 --> 00:04:33.830
入力フィーチャのメトリックと葉の儀式対応
するインデックス。

84
00:04:33.830 --> 00:04:39.840
xgboost では、また、なぜパラメー
タを予測する方法で葉の品種をサポートしま
す。

85
00:04:39.840 --> 00:04:42.730
私たちは、ドキュメントを共同作業するため
に必要な提案

86
00:04:42.730 --> 00:04:46.420
これらのメソッドとミピスの詳細については
、こちらを参照してください。

87
00:04:46.420 --> 00:04:48.210
このビデオの最後に、

88
00:04:48.210 --> 00:04:50.250
主なポイントに取り組もうと思います。

89
00:04:50.250 --> 00:04:54.960
我々は, カテゴリ機能の相互作用を構築す
る方法を検討した.

90
00:04:54.960 --> 00:04:58.135
また、我々は、実際の値の機能へのアプロー
チを拡張します。

91
00:04:58.135 --> 00:05:00.610
そして、我々はどのように抽出するために木
を使用することを学んだ

92
00:05:00.610 --> 00:05:04.510
高次の相互作用。ご注意をありがとうござい
ました。

