1
00:00:00.031 --> 00:00:05.036
音こんにちは、この瞬間に、我々はすでにす
べてを議論している

2
00:00:05.036 --> 00:00:11.817
基本は、注目世代のような大きなソリューシ
ョンを構築する新しいもの、

3
00:00:11.817 --> 00:00:15.800
検証、ミニマルコーディングなど。

4
00:00:15.800 --> 00:00:19.374
我々は一緒にいくつかの大会を経て、

5
00:00:19.374 --> 00:00:24.204
我々は一つの巨大な枠組みに学ぶすべてを団
結するために最善を尽くした。

6
00:00:24.204 --> 00:00:28.769
しかし、ツールの他のセットと同様に、多く
のヒューリスティックがあります

7
00:00:28.769 --> 00:00:32.471
人々はしばしば試行錯誤のアプローチでのみ
、見つける

8
00:00:32.471 --> 00:00:37.534
これらのツールを効率的に使用する方法の学
習に多大な時間を費やす。

9
00:00:37.534 --> 00:00:39.216
だから、ここであなたを助けるために、

10
00:00:39.216 --> 00:00:45.100
このビデオでは、我々は経験によって、ハー
ドな方法を学んだことを共有します。

11
00:00:45.100 --> 00:00:48.560
これらのことは、人によって異なる場合があ
ります。

12
00:00:48.560 --> 00:00:53.140
だから我々は、クラスの誰もが個人的に自分
のガイドラインを提示することを決めた

13
00:00:53.140 --> 00:00:57.770
広範な問題で可能な多様性を強調し、

14
00:00:57.770 --> 00:01:00.650
異なる瞬間にアクセントを作るために。

15
00:01:00.650 --> 00:01:04.150
いくつかのメモはあなたに明らかに見えるか
もしれない,
いくつかはないかもしれない.

16
00:01:04.150 --> 00:01:08.940
しかし、それらのいくつかのためにも、少な
くとも誰もそれらを含むことを確認してくだ
さい。

17
00:01:08.940 --> 00:01:10.940
多くの時間を節約することができます。

18
00:01:10.940 --> 00:01:13.242
では、始めましょう。

19
00:01:13.242 --> 00:01:16.992
我々は競争を入力したい場合は、あなたの目
標を定義し、

20
00:01:16.992 --> 00:01:21.470
あなたの参加を得ることができるものを推定
してみてください。

21
00:01:21.470 --> 00:01:25.000
興味深い問題について詳しく知りたい場合が
あります。

22
00:01:25.000 --> 00:01:27.790
あなたは、新しいソフトウェアツールを使用
して知り合いになることがあります

23
00:01:27.790 --> 00:01:32.320
パッケージ、またはメダルを捜すことを試み
たいと思う場合もある。

24
00:01:32.320 --> 00:01:37.450
これらの目標の各々は、あなたが参加するこ
とを選択した競争に影響を与えます。

25
00:01:37.450 --> 00:01:40.380
興味深い問題について詳しく知りたい場合は
、

26
00:01:40.380 --> 00:01:44.350
あなたは、競争がフォーラムで広い討論をす
ることを望むかもしれません。

27
00:01:44.350 --> 00:01:49.950
例えば、データサイエンスに興味があるなら
、医学への応用で、

28
00:01:49.950 --> 00:01:55.210
あなたは、データサイエンスボウル2017
で肺がんを予測しようとすることができます
。

29
00:01:55.210 --> 00:01:59.900
または長期の人間の脳波記録の発作を予測す
る。

30
00:01:59.900 --> 00:02:03.070
メルボルン大学の発作予測の競争。

31
00:02:04.240 --> 00:02:07.200
新しいソフトウェアツールを使用して知り合
いになりたい場合は、

32
00:02:07.200 --> 00:02:10.000
あなたは、競争が必要なチュートリアルを持
ってすることができます。

33
00:02:10.000 --> 00:02:13.530
たとえば、ニューラルネットワークライブラ
リを学習したい場合です。

34
00:02:13.530 --> 00:02:17.818
あなたは自然保護のような画像との競争のい
ずれかを選択することができます

35
00:02:17.818 --> 00:02:19.880
機能は、競争を監視する。

36
00:02:19.880 --> 00:02:24.560
または惑星、宇宙の競争からアマゾンを理解
する。

37
00:02:24.560 --> 00:02:27.100
そして、あなたが狩りをしようとする場合

38
00:02:27.100 --> 00:02:32.260
メダルは、参加者が持っているどのように多
くの提出を確認することができます。

39
00:02:32.260 --> 00:02:36.260
そして、ポイントは、人々が100以上の提
出を持っている場合、

40
00:02:36.260 --> 00:02:41.030
これは、読みやすい問題や検証の難しさの明
確な兆候をすることができます

41
00:02:41.030 --> 00:02:45.380
検証とスコアボードスコアの不一致が含まれ
ています。

42
00:02:45.380 --> 00:02:49.840
一方、トップでの応募が少ない人がいれば、

43
00:02:49.840 --> 00:02:54.810
それは通常、この競争への非自明なアプロー
チがあるべきであることを意味

44
00:02:54.810 --> 00:02:58.100
またはそれは少数の人々によってだけ発見さ
れる。

45
00:02:58.100 --> 00:03:03.030
その横には、トップチームのサイズに注意を
払う必要があります。

46
00:03:03.030 --> 00:03:07.210
リーダーボードが主に参加者が1人だけのチ
ームで構成されている場合、

47
00:03:07.210 --> 00:03:10.660
あなたは良いチームを収集する場合は、おそ
らく十分なチャンスがあるでしょう。

48
00:03:11.750 --> 00:03:16.300
さて、次のステップには、競争を選択した後
に移動してみましょう。

49
00:03:16.300 --> 00:03:19.060
データに慣れるとすぐに、

50
00:03:19.060 --> 00:03:23.560
あなたが後で試みたいと思うかもしれないも
のについてのあなたの考えを書き始める。

51
00:03:23.560 --> 00:03:25.320
何がここで働くことができる?

52
00:03:25.320 --> 00:03:27.840
どのようなアプローチを取る必要があります
。

53
00:03:27.840 --> 00:03:32.860
完了したら、フォーラムを読んで、興味深い
記事やトピックを強調表示します。

54
00:03:32.860 --> 00:03:37.130
覚えて、多くの情報を取得し、フォーラムで
新しい人を満たすことができます。

55
00:03:37.130 --> 00:03:42.640
だから私は強く、これらの議論に参加するこ
とをお勧めします。

56
00:03:42.640 --> 00:03:45.000
初期パイプラインの準備が完了し、

57
00:03:45.000 --> 00:03:49.710
いくつかのアイデアをロールダウンすると、
ソリューションの改善を開始することができ
ます。

58
00:03:49.710 --> 00:03:53.910
個人的に、私はいくつかの構造にこれらのア
イデアを整理したい。

59
00:03:53.910 --> 00:03:58.330
従って考えを優先順位に分類したいと思う場
合もある。

60
00:03:58.330 --> 00:04:01.470
最も重要かつ有望な最初の実装する必要があ
ります。

61
00:04:02.520 --> 00:04:05.870
またはトピックにこれらの考えを整理したい
と思う場合もある。

62
00:04:05.870 --> 00:04:10.540
機能の生成、検証、メトリックの最適化に関
するアイデア。

63
00:04:10.540 --> 00:04:11.660
などなど。

64
00:04:11.660 --> 00:04:15.330
今すぐアイデアをピックアップし、それを実
装します。

65
00:04:15.330 --> 00:04:17.571
途中でいくつかの洞察を導出してみてくださ
い。

66
00:04:17.571 --> 00:04:22.790
特に、何かが動作しないかどうかを理解しよ
うとします。

67
00:04:22.790 --> 00:04:23.583
例えば

68
00:04:23.583 --> 00:04:27.826
あなたは深いグラデーションブーストデシジ
ョンツリーモデルをしようとする考えを持っ
ている。

69
00:04:27.826 --> 00:04:30.420
あなたの喜びに、それが動作します。

70
00:04:30.420 --> 00:04:32.500
今、自分に理由を聞いてみては?

71
00:04:32.500 --> 00:04:36.060
前に気付かなかった隠されたデータ構造はあ
りますか?

72
00:04:36.060 --> 00:04:41.260
たぶん、あなたは、独特の価値の多くでカテ
ゴリー特徴を持っています。

73
00:04:41.260 --> 00:04:42.570
このような場合は、

74
00:04:42.570 --> 00:04:47.560
あなたは、エンコーディングがここでうまく
いくかもしれないという結論を出すことがで
きます。

75
00:04:47.560 --> 00:04:51.390
だからある意味、仕事を分析する能力と

76
00:04:51.390 --> 00:04:54.810
あなたのアイデアを試している間に結論を導
き出す

77
00:04:54.810 --> 00:04:58.720
隠されたデータパターンとリークを明らかに
するために右のトラックにあなたを取得しま
す。

78
00:04:59.830 --> 00:05:02.670
最も重要なアイデアを調べた後

79
00:05:02.670 --> 00:05:05.510
パラメータのトレーニングに切り替えること
ができます。

80
00:05:05.510 --> 00:05:08.820
私は個人的には、ビューのように、すべての
パラメータです。

81
00:05:08.820 --> 00:05:13.280
特徴の数から、深さによって決定を高める勾
配によって。

82
00:05:13.280 --> 00:05:16.620
畳み込みニューラルネットワークの層数から
,

83
00:05:16.620 --> 00:05:20.130
あなたが最終的に提出係数に乗算されます。

84
00:05:20.130 --> 00:05:22.240
私は何を調整する必要があります理解するた
めに

85
00:05:22.240 --> 00:05:27.020
最初の変更は、私はこれらの原則によってす
べてのパラメータを並べ替えるように。

86
00:05:27.020 --> 00:05:28.475
まず、重要性。

87
00:05:28.475 --> 00:05:32.850
重要なパラメータを、まったく役に立たない
ように配置します。

88
00:05:32.850 --> 00:05:34.560
この順序で調整します。

89
00:05:34.560 --> 00:05:39.238
これらは、データ構造、ターゲット、メトリ
ックなどに依存する場合があります。

90
00:05:39.238 --> 00:05:41.842
第二に、実現可能性。

91
00:05:41.842 --> 00:05:47.758
レートパラメータから、これは永遠に取るこ
とができるチューニングするには、調整する
ことは簡単です。

92
00:05:47.758 --> 00:05:49.916
第三に、理解。

93
00:05:49.916 --> 00:05:55.370
レートパラメータから、私はそれが何をして
いるかを知って、私は考えている。

94
00:05:55.370 --> 00:05:59.420
ここでは、各パラメータが変更されるかを理
解することが重要です

95
00:05:59.420 --> 00:06:00.510
全体のパイプラインで。

96
00:06:00.510 --> 00:06:04.430
たとえば、フィーチャの数を大幅に増やすと
、

97
00:06:04.430 --> 00:06:08.430
最もよい分割を見つけるのに使用されるコラ
ムの比率を変えたいと思う場合もある

98
00:06:08.430 --> 00:06:10.860
グラデーションブーストデシジョンツリーで
。

99
00:06:10.860 --> 00:06:14.551
または、畳み込みニューラルネットワークの
レイヤ数を変更すると、

100
00:06:14.551 --> 00:06:17.284
あなたはそれを訓練するために、より多くの
レポートが必要になります。

101
00:06:17.284 --> 00:06:22.945
だから、これらは私の実用的なガイドライン
の一部だった見てみましょう、

102
00:06:22.945 --> 00:06:27.169
私はそれらがあなたのためにまた有用証明す
ることを望む。

103
00:06:27.169 --> 00:06:30.890
すべての問題は、データの読み込みと前処理
から始まります。

104
00:06:30.890 --> 00:06:35.540
私は通常、計算のいくつかのサブ最適な使用
に多くの注意を払っていない

105
00:06:35.540 --> 00:06:40.740
リソースが、この特定のケースは非常に重要
です。

106
00:06:40.740 --> 00:06:45.030
非常に最初に物事を行うことは、あなたの人
生ははるかに簡単になります

107
00:06:45.030 --> 00:06:49.670
多くの時間および計算資源を救うことを可能
にする。

108
00:06:49.670 --> 00:06:53.530
私は通常、ラベリングのような基本的なデー
タの前処理から始まり、

109
00:06:53.530 --> 00:06:57.780
コーディング、カテゴリの回復、両方の追加
データを楽しんでいます。

110
00:06:57.780 --> 00:07:05.380
次に、結果のデータを HDF5 または
MPI 形式にダンプします。

111
00:07:05.380 --> 00:07:10.820
パンダの dataframes のための
HDF5、および非ビット配列のための
MPI。

112
00:07:10.820 --> 00:07:15.321
多くの場合、実行中の実験には多くのカーネ
ルの再起動が必要

113
00:07:15.321 --> 00:07:18.250
これは、すべてのデータをリロードにつなが
る。

114
00:07:18.250 --> 00:07:23.146
また、クラス CSC ファイルの読み込み
には数分かかる場合があります。

115
00:07:23.146 --> 00:07:28.610
HDF5 または MPI 形式からのデー
タの読み込みは、ほんの数秒で実行されます
。

116
00:07:29.870 --> 00:07:35.275
もう一つの重要な問題は、デフォルトでは、
パンダを格納するために知られている

117
00:07:35.275 --> 00:07:41.251
64ビット配列のデータであり、ほとんどの
状況では不要です。

118
00:07:41.251 --> 00:07:48.330
32ビットにすべてをダウンキャストすると
、2倍のメモリ節約になります。

119
00:07:48.330 --> 00:07:54.280
また、心の中では、ボックスのデータをチャ
ンクで再リンクのパンダのサポートを維持す
る

120
00:07:54.280 --> 00:07:58.530
を介してチャンク氷のパラメータは、凹部の
手数料関数です。

121
00:07:58.530 --> 00:08:03.680
ほとんどのデータセットは、多くのメモリを
使用せずに処理される可能性があります。

122
00:08:03.680 --> 00:08:09.313
ときに、パフォーマンスの評価になると、私
は大規模な検証の大きなファンではない。

123
00:08:09.313 --> 00:08:15.665
5万または10万行のような中規模のデータ
セットでも。

124
00:08:15.665 --> 00:08:20.235
単純な列車テストスプリットでモデルを検証
することができます

125
00:08:20.235 --> 00:08:23.412
完全なクロス検証ループの代わりに。

126
00:08:23.412 --> 00:08:27.490
本当に必要なときだけフル CV
に切り替えます。

127
00:08:27.490 --> 00:08:30.940
たとえば、既にいくつかの制限をヒットして

128
00:08:30.940 --> 00:08:34.970
いくつかの限界の改善だけで前方に移動する
ことができます。

129
00:08:34.970 --> 00:08:38.020
最初のモデル選択にも同じロジックが適用さ
れます。

130
00:08:38.020 --> 00:08:42.580
私は通常、LightGBM で起動すると
、いくつかの合理的に良いパラメータを見つ
ける

131
00:08:42.580 --> 00:08:45.119
、自分の機能のパフォーマンスを評価します
。

132
00:08:46.290 --> 00:08:50.500
早めの停車を使うことを強調したいので、

133
00:08:50.500 --> 00:08:53.820
私は、ブーストイテレーションの数を調整す
る必要はありません。

134
00:08:55.150 --> 00:08:59.980
そして神は開始の ESVMs、不規則なフ
ォーク、または禁止する

135
00:08:59.980 --> 00:09:05.520
ニューラルネットワークは、あまりにも多く
の時間を無駄にするだけでフィードを待って
いる。

136
00:09:05.520 --> 00:09:08.780
私は、モデルのチューニングに切り替えると
、サンプリング、および

137
00:09:08.780 --> 00:09:12.700
私は機能エンジニアリングに満足していると
きにのみ、しめ。

138
00:09:13.760 --> 00:09:19.400
いくつかの点で、私は、高速かつ汚い、常に
良いとして私のアプローチを説明します。

139
00:09:19.400 --> 00:09:23.010
本当に重要なことに焦点を当ててみてくださ
い, データ.

140
00:09:23.010 --> 00:09:25.661
エド、別の機能を試してください。

141
00:09:25.661 --> 00:09:28.577
Google ドメイン固有の知識。

142
00:09:28.577 --> 00:09:31.020
コードはセカンダリです。

143
00:09:31.020 --> 00:09:33.210
不要なクラスの作成と

144
00:09:33.210 --> 00:09:37.260
個人的なフレームボックスは、物事を変更す
ることを難しくすることがあります

145
00:09:37.260 --> 00:09:43.170
あなたの時間を無駄にするので、物事をシン
プルかつ合理的に保つ結果になります。

146
00:09:43.170 --> 00:09:45.745
すべての小さな変化を追跡しないでください
。

147
00:09:45.745 --> 00:09:49.680
競争の終わりまでに、私は通常のためのノー
ト pc のカップルを持っている

148
00:09:49.680 --> 00:09:55.490
モデルのトレーニングと EDA 目的のた
めに具体的にノートブックをしたい。

149
00:09:55.490 --> 00:10:01.660
最後に、与えられた計算資源に本当に違和感
を感じたら、

150
00:10:01.660 --> 00:10:05.290
何週間も苦労しないで、単に大規模なサーバ
ーを借りる。

151
00:10:06.710 --> 00:10:09.790
すべての競争は、私は非常にシンプルな基本
ソリューションを開始

152
00:10:09.790 --> 00:10:11.590
それも原始的なことができます。

153
00:10:11.590 --> 00:10:15.950
このようなソリューションの主な目的は、良
いモデルを構築することではなく、

154
00:10:15.950 --> 00:10:18.960
最初から完全なパイプラインをデバッグする
には

155
00:10:18.960 --> 00:10:23.550
我々は決定された形式に提出ファイルを書く
ときに最後にデータの。

156
00:10:23.550 --> 00:10:26.820
私は最初のパイプラインの建設から始めるこ
とをお勧めします。

157
00:10:26.820 --> 00:10:30.322
多くの場合、ベースラインソリューションで
それを見つけることができます主催者によっ
て提供または

158
00:10:30.322 --> 00:10:31.270
カーネルで。

159
00:10:31.270 --> 00:10:33.630
じっくり読んで、自分なりに書くことをお勧
めします。

160
00:10:34.890 --> 00:10:39.270
また、私はあなたが他のもので簡単に複雑な
アプローチから従うことをお勧めします。

161
00:10:39.270 --> 00:10:41.800
例えば、私はランダムな森ではなく、開始す
ることを好む

162
00:10:41.800 --> 00:10:43.360
グラデーションブーストデシジョンツリー。

163
00:10:43.360 --> 00:10:45.438
少なくともランダムな森林は非常に速く動作
し、

164
00:10:45.438 --> 00:10:47.869
ハイブリッドパラメータのチューニングはほ
とんど必要ありません。

165
00:10:49.060 --> 00:10:52.660
データ科学の競争への参加は、データの分析
を意味し、

166
00:10:52.660 --> 00:10:55.530
モデルによる機能と操作の生成。

167
00:10:55.530 --> 00:10:59.570
このプロセスは、ソフトウェアの開発と精神
で非常によく似ています

168
00:10:59.570 --> 00:11:02.390
私はあなたに従うことをお勧め多くの良い慣
行があります。

169
00:11:02.390 --> 00:11:03.750
私はそれらのほんの一部を命名します。

170
00:11:04.910 --> 00:11:07.650
まず第一に、良い変数名を使用します。

171
00:11:07.650 --> 00:11:10.470
どんなに独創的でも、コードが下手に書けば
、

172
00:11:10.470 --> 00:11:14.210
あなたは確かにそれで混乱を取得し、遅かれ
早かれ問題があるでしょう。

173
00:11:15.450 --> 00:11:17.750
第二に、あなたの研究を再現してください。

174
00:11:17.750 --> 00:11:18.973
すべてのランダムな種子を修正します。

175
00:11:18.973 --> 00:11:21.780
フィーチャの生成方法を正確に書き留め、

176
00:11:21.780 --> 00:11:24.800
git のようなバージョン管理システムの
下にコードを保存します。

177
00:11:24.800 --> 00:11:27.800
非常に多くの場合は、モデルに戻る必要があ
る場合は、状況がある

178
00:11:27.800 --> 00:11:30.962
2週間前に建てられ、アンサンブルの幅に編
集します。

179
00:11:30.962 --> 00:11:34.920
最後に、おそらく最も重要なことは、コード
を再利用します。

180
00:11:34.920 --> 00:11:38.568
実際には、トレーニングとテストの段階で同
じコードを使用することが重要です。

181
00:11:38.568 --> 00:11:42.040
たとえば、機能を準備し、同じコードで変換
する必要があります。

182
00:11:42.040 --> 00:11:46.565
彼らは一貫した方法で生産されていることを
保証するために。

183
00:11:46.565 --> 00:11:49.290
ここではこのような場所では非常にキャッチ
するのは難しいので、

184
00:11:49.290 --> 00:11:51.540
それにはとても気をつけた方がいいですよ。

185
00:11:51.540 --> 00:11:55.985
再利用可能なコードを別の関数または別のモ
デルに移動することをお勧めします。

186
00:11:57.090 --> 00:11:59.610
また、私はトピックに関する科学的な記事を
読むことをお勧め

187
00:11:59.610 --> 00:12:01.450
競争の。

188
00:12:01.450 --> 00:12:03.880
彼らは、マシンに関する情報を提供すること
ができます

189
00:12:03.880 --> 00:12:08.560
たとえば、測定を最適化する方法や AUC
などの相関関係があります。

190
00:12:08.560 --> 00:12:10.300
または、問題の主な知識を提供します。

191
00:12:11.710 --> 00:12:14.460
これは、多くの場合、将来の世代のために便
利です。

192
00:12:14.460 --> 00:12:18.290
たとえば、マイクロソフトのモバイル競争の
中で、私は携帯電話についての記事を読む

193
00:12:18.290 --> 00:12:21.410
それらからの検出そして使用された考えは新
しい特徴を生成するために。

194
00:12:22.710 --> 00:12:26.535
> > 私は通常、フォーラムやカーネルを
監視することにより、競争を開始します。

195
00:12:27.560 --> 00:12:32.720
これは、競争が開始されると、誰かがデータ
のバグを見つけることが起こる。

196
00:12:32.720 --> 00:12:37.010
そして競争データはそれから完全に変えられ
る、従って

197
00:12:37.010 --> 00:12:39.820
私は、その非常に最初に競争に参加すること
はありません。

198
00:12:41.390 --> 00:12:45.690
私は通常、簡単な EDA とシンプルなベ
ースラインとの競争を開始します。

199
00:12:45.690 --> 00:12:49.080
いろいろな漏電のデータをチェックしてみま
した。

200
00:12:49.080 --> 00:12:54.280
私にとって、リークは、競争の中で最も興味
深い部分の一つです。

201
00:12:54.280 --> 00:12:57.710
私は、通常、検証のスコアを確認するために
いくつかの提出を行う

202
00:12:57.710 --> 00:12:59.710
公にボードスコアと相関します。

203
00:13:01.480 --> 00:13:05.630
通常、私は競争にしようとするもののリスト
を思い付くしようとすると、

204
00:13:05.630 --> 00:13:07.660
私はそれに従うことを試みる。

205
00:13:08.880 --> 00:13:13.270
しかし、時には私はできるだけ多くの機能を
生成しようとすると、

206
00:13:13.270 --> 00:13:17.364
余分なブーストでそれらを入れて、何が役立
つと何をしない勉強。

207
00:13:17.364 --> 00:13:22.440
パラメータをチューニングするときに、まず
モデル overfit
を作成してみます。

208
00:13:22.440 --> 00:13:26.880
トレーニングセットにしてのみ、私はモデル
を制約するパラメータを変更します。

209
00:13:28.050 --> 00:13:32.908
私は私が私の服従の1つを再現できなかった
状態を有した。

210
00:13:32.908 --> 00:13:36.630
私は誤ってコードで何かを変更し、私は何を
思い出すことができなかった

211
00:13:36.630 --> 00:13:42.200
正確には、今日ので、私は非常に私のコード
とスクリプトに注意しています。

212
00:13:44.040 --> 00:13:45.114
別の問題?

213
00:13:45.114 --> 00:13:51.220
ノートブックの長い実行履歴は、定義された
グローバル変数の多くにつながります。

214
00:13:51.220 --> 00:13:54.340
グローバル変数は確実にバグにつながります
。

215
00:13:54.340 --> 00:13:57.220
だから時々ノートパソコンを再起動してくだ
さい。

216
00:13:58.280 --> 00:14:03.170
これは、提出を生成するために使用しない限
り、醜いコードを持って、大丈夫です。

217
00:14:04.390 --> 00:14:05.240
それは容易である

218
00:14:05.240 --> 00:14:09.350
説明変数名がある場合は、後でこのコードを
取得します。

219
00:14:09.350 --> 00:14:13.720
私はいつも git
を使用して、コードを作成しようとする

220
00:14:13.720 --> 00:14:16.850
可能な限り透過的に送信します。

221
00:14:16.850 --> 00:14:18.840
私は通常、別のノートブックを作成する

222
00:14:18.840 --> 00:14:23.320
すべての提出ので、私は常に前のソリューシ
ョンを実行し、比較することができます。

223
00:14:24.420 --> 00:14:27.720
そして私は原稿として服従のノートを扱う。

224
00:14:27.720 --> 00:14:31.550
私は、カーネルを再起動し、常に上から下に
それらを実行します。

225
00:14:32.808 --> 00:14:37.672
私は、検証を使用することができますモデル
を検証するための便利な方法を発見

226
00:14:37.672 --> 00:14:41.937
データセット全体でモデルを再トレーニング
するための変更を最小限に抑えたコード。

227
00:14:41.937 --> 00:14:46.420
競争の中で、我々はトレーニングとテスト
CSV ファイルを提供しています。

228
00:14:46.420 --> 00:14:47.610
我々は最初のセルにそれらをロード参照して
ください。

229
00:14:47.610 --> 00:14:52.820
2番目のセルでは、トレーニングセットと実
際のトレーニングを分割し、

230
00:14:52.820 --> 00:14:57.367
検証を設定し、それらをディスクに CSV
ファイルとして保存します。

231
00:14:57.367 --> 00:15:01.460
指定された列車 csv とテスト csv
と同じ構造。

232
00:15:03.060 --> 00:15:08.240
今、ノートブックの上部に、私のモデルで、
私は変数を定義します。

233
00:15:08.240 --> 00:15:11.320
パスは、セットを訓練し、テストすることで
す。

234
00:15:11.320 --> 00:15:12.834
私は訓練を作成するためにそれらを設定し、

235
00:15:12.834 --> 00:15:15.970
検証は、モデルを操作して検証するときに設
定します。

236
00:15:16.990 --> 00:15:22.050
そして、それだけで、元の列車の CSV
に、これらのパスを切り替えるにかかる

237
00:15:22.050 --> 00:15:24.290
CSV をテストして提出を作成します。

238
00:15:25.450 --> 00:15:27.700
私もマクロを使用します。

239
00:15:27.700 --> 00:15:32.230
1つの時点で私は本当に np
としてインポート numpy
を入力するには、毎回うんざりしていた。

240
00:15:33.840 --> 00:15:38.260
だから私はそれが私のためにすべてをロード
するマクロを定義することが可能であること
がわかった。

241
00:15:40.110 --> 00:15:42.610
私の場合は、それだけで5つのシンボルを取
る

242
00:15:44.020 --> 00:15:49.810
マクロ名を入力し、このマクロはすぐに私に
すべてをロードします。

243
00:15:49.810 --> 00:15:50.490
とても便利です。

244
00:15:52.540 --> 00:15:56.860
そして最後に、私は頻繁に使用される機能を
持つ私のライブラリを開発しており、

245
00:15:56.860 --> 00:15:58.870
モデルのトレーニングコード。

246
00:15:58.870 --> 00:16:04.544
私は個人的にそれが有用な、コードとして、
それは今、はるかに短くなる見つける

247
00:16:04.544 --> 00:16:09.395
そして、私はどのように特定のモデルをイン
ポートすることを覚えておく必要はありませ
ん。

248
00:16:09.395 --> 00:16:14.117
私の場合、私はちょうどその名前を持つモデ
ルを指定し、

249
00:16:14.117 --> 00:16:21.795
出力として私は私がおそらく必要とする訓練
についてのすべての情報を得る。

250
00:16:21.795 --> 00:16:24.514
音

251
00:16:24.514 --> 00:16:31.699
音楽

