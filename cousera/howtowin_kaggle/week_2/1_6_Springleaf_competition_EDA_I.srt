1
00:00:00.000 --> 00:00:03.260
音楽

2
00:00:03.260 --> 00:00:07.649
だから、このビデオでは、私はスプリングリ
ーフデータを通過する、

3
00:00:07.649 --> 00:00:11.260
Kaggle の競争だった

4
00:00:11.260 --> 00:00:15.430
その競争の中で、競合他社は

5
00:00:15.430 --> 00:00:20.070
クライアントがスプリングリーフによって提
供されるダイレクトメールの提供に応答する
かどうかを予測します。

6
00:00:20.070 --> 00:00:22.940
おそらく、我々は、クライアントについてい
くつかの機能があるでしょう

7
00:00:22.940 --> 00:00:28.115
オファーについていくつかの機能、そして我
々は彼が応答する場合は1を予測する必要が
あります

8
00:00:28.115 --> 00:00:30.980
彼がいない場合は0なので、始めましょう。

9
00:00:30.980 --> 00:00:34.440
まずここにいくつかのライブラリをインポー
トし、いくつかの関数を定義します。

10
00:00:34.440 --> 00:00:35.870
あまり面白くないですね。

11
00:00:35.870 --> 00:00:41.290
そして最後に、データをロードしてみましょ
う

12
00:00:41.290 --> 00:00:45.230
テスト1をトレーニングし、データの概要を
少し実行します。

13
00:00:45.230 --> 00:00:50.679
だから我々のデータについて知りたい最初の
ものは、データテーブルの形状であり、

14
00:00:50.679 --> 00:00:54.953
それでは、電車の形を持って、テストの形状
をテストしてみましょう。

15
00:00:54.953 --> 00:01:00.519
我々はここを参照してください、我々は電車
の中で、両方の 1
15万オブジェクトを持っている

16
00:01:00.519 --> 00:01:05.790
テストセット、および電車とテストの両方で
約2000の機能。

17
00:01:05.790 --> 00:01:10.672
そして、我々はより多くを参照してください
、我々は電車の中でもう一つの機能を持って
いる、と

18
00:01:10.672 --> 00:01:15.120
人間として、ちょうどターゲットは列車を動
かし続けることができる。

19
00:01:15.120 --> 00:01:19.160
だから、念のために注意しておくべきだし、

20
00:01:19.160 --> 00:01:21.820
モデルをフィードするときにこの列を削除し
ます。

21
00:01:23.420 --> 00:01:25.490
そこでトレーニングやテストを調べてみて、

22
00:01:25.490 --> 00:01:30.770
ので、この関数は、両方のいくつかの行を印
刷していた使用してみましょう。

23
00:01:30.770 --> 00:01:35.884
ここでは、ID 列があり、ここで興味深い
のは、私が見ることです

24
00:01:35.884 --> 00:01:41.422
トレーニング我々は値を持っている 2,
4, 5, 7, とテストで我々は 1,
3, 6, 9 を持っている。

25
00:01:41.422 --> 00:01:45.102
そして、それは彼らが重複していないように
思える、と

26
00:01:45.102 --> 00:01:49.153
私は、生成プロセスは、次のようだったと仮
定します。

27
00:01:49.153 --> 00:01:55.438
だから、主催者は、巨大なデータを30万ル
ールを設定し、作成

28
00:01:55.438 --> 00:02:01.630
そして、彼らはランダムにサンプリング,
列車のための行とテストのための.

29
00:02:01.630 --> 00:02:05.747
そして、それは基本的にどのように我々はこ
の列車とテストを取得し、

30
00:02:05.747 --> 00:02:10.660
我々は、この列 IG を持って、それはこ
の元の巨大なファイルの行インデックスです
。

31
00:02:10.660 --> 00:02:16.197
次に、何かのカテゴリを持って、何かの数字
、

32
00:02:16.197 --> 00:02:22.970
数値または、カテゴリ、数値またはバイナリ
にすることができます何か。

33
00:02:22.970 --> 00:02:27.791
しかし、あなたは小数部を持って参照してく
ださいので、私は理由を知らない

34
00:02:27.791 --> 00:02:35.100
その後、ここでいくつかの非常に奇妙な値、
そして再び、何かのカテゴリ。

35
00:02:35.100 --> 00:02:38.850
そして、実際には、我々の間にたくさんある
、とはい、

36
00:02:38.850 --> 00:02:44.740
列車セットの最後の列として目標を持ってい
るので、移動しましょう。

37
00:02:44.740 --> 00:02:49.766
おそらく我々がチェックしたい別のものは、
我々は数字を持っていないかどうかです

38
00:02:49.766 --> 00:02:55.180
私たちのデータセットでは、nonce の
値のように、我々はいくつかの方法でそれを
行うことができます。

39
00:02:55.180 --> 00:02:58.250
そして、1つの方法我々は、

40
00:02:58.250 --> 00:03:02.870
各オブジェクトに対して、各行に対して
NaNs の数を計算してみましょう。

41
00:03:02.870 --> 00:03:06.870
だから、これは実際に我々はここで何をすべ
きか、

42
00:03:06.870 --> 00:03:11.856
最初の15行の値のみを印刷します。

43
00:03:11.856 --> 00:03:15.502
したがって、行0には 25 NaNs
があり、

44
00:03:15.502 --> 00:03:19.848
行1には19の NaN がありますが、

45
00:03:19.848 --> 00:03:26.180
ここで興味深いのは、6行に 24
NaNs があります。

46
00:03:26.180 --> 00:03:29.245
我々はランダムにそれを得たように、それは
見ていない

47
00:03:29.245 --> 00:03:32.785
それは本当にランダムにこれらを持っている
可能性は低い。

48
00:03:32.785 --> 00:03:39.900
だから私の仮説は、行の順序は、いくつかの
構造を持っている可能性がありますので、

49
00:03:39.900 --> 00:03:45.640
行がシャッフルされていません, 我々はパ
ターンのこの種を持っている理由です.

50
00:03:45.640 --> 00:03:50.813
そして、それは我々はおそらく行のインデッ
クスを使用することを意味

51
00:03:50.813 --> 00:03:56.592
私達の分類器のための別の特徴として、そう
それはある。

52
00:03:56.592 --> 00:04:01.430
そして、同じ、私たちは列で行うことができ
ますので、

53
00:04:01.430 --> 00:04:05.280
各列について、各列にある NaNs
の数を計算してみましょう。

54
00:04:05.280 --> 00:04:10.480
そして、我々は、ID が 0 NaNs
を持って、その後いくつかの0s
を参照してください

55
00:04:10.480 --> 00:04:16.330
その後、我々は、列の多くは、同じ 56
NaNs を持っていることがわかります。

56
00:04:16.330 --> 00:04:21.350
そして、それは再び何か本当に奇妙なので、
いずれかのすべての列が

57
00:04:21.350 --> 00:04:27.040
56 NaNs を持っているので、それは
魔法ではない、それはおそらく物事が行く方
法だけです。

58
00:04:27.040 --> 00:04:32.660
しかし、我々は、列の多くがあることを知っ
ていれば、すべての列が

59
00:04:33.790 --> 00:04:38.119
NaNs のより多くの異なる数は、それは
本当に列の多くを持っている可能性は低い

60
00:04:40.330 --> 00:04:44.380
NaNs
の同じ数のデータセットでお互いに近い。

61
00:04:44.380 --> 00:04:49.250
だからおそらく、我々の仮説は、ここでは、
列の順序

62
00:04:49.250 --> 00:04:53.330
ランダムではないので、おそらくこれを調査
することができます。

63
00:04:55.930 --> 00:04:59.600
したがって、このデータには約2000の列
があり、

64
00:04:59.600 --> 00:05:02.312
これは、列の本当に膨大な数です。

65
00:05:02.312 --> 00:05:05.770
そして、このデータセットを操作するのは本
当に難しいですし、

66
00:05:05.770 --> 00:05:08.340
基本的には名前を持っていないので、データ
はマウスのみです。

67
00:05:09.940 --> 00:05:13.314
言ったように、まず最初にできることは、

68
00:05:13.314 --> 00:05:18.098
データの種類を決定するために、ここでそれ
を行います。

69
00:05:18.098 --> 00:05:23.053
だから我々は最初の列車を継続し、巨大なデ
ータフレーム上でテストしようとしている

70
00:05:23.053 --> 00:05:27.845
主催者が持っていたように、それは30万行
を持つことになります。

71
00:05:27.845 --> 00:05:31.800
まず、独自の関数を使用して、

72
00:05:31.800 --> 00:05:36.284
各列の一意の値の数を決定します。

73
00:05:36.284 --> 00:05:41.742
そして、基本的にここで我々は我々が見つけ
たもののいくつかの値をもたらす

74
00:05:41.742 --> 00:05:48.390
そして、それは1つだけユニークな番号を持
つ5つの列があるように思える。

75
00:05:48.390 --> 00:05:52.021
基本的にはここにあるものを落とせます

76
00:05:52.021 --> 00:05:56.020
我々は、この行でそれらを見つけるし、我々
はそれらをドロップします。

77
00:05:56.020 --> 00:06:01.025
次に、重複した機能を削除したいのですが、
まず、

78
00:06:01.025 --> 00:06:05.829
便宜のために、何かではなく、数字を埋める

79
00:06:05.829 --> 00:06:10.550
私たちは簡単に後で見つけることができます
し、次のようにします。

80
00:06:10.550 --> 00:06:14.494
だから我々は、サイズの別のデータフレーム
を作成する

81
00:06:14.494 --> 00:06:18.327
訓練セットと同じような形の。

82
00:06:18.327 --> 00:06:22.089
列車セットから列を取る

83
00:06:22.089 --> 00:06:27.788
前のビデオで説明したように、ラベルエンコ
ーダーを適用します。

84
00:06:27.788 --> 00:06:32.114
そして、我々は基本的にこの新しい列車のセ
ットに格納します。

85
00:06:32.114 --> 00:06:34.940
だから、基本的に我々は列車である別のデー
タフレームを取得し、

86
00:06:34.940 --> 00:06:38.440
しかし、ラベルエンコードされた列車セット
。

87
00:06:38.440 --> 00:06:44.340
そして、このデータフレームを持つ、我々は
簡単に重複した機能を見つけることができま
す

88
00:06:44.340 --> 00:06:49.250
我々はちょうど2つの反復子を持つ機能の反
復を開始します。

89
00:06:49.250 --> 00:06:54.580
基本的には、1つは固定され、2番目の1つ
は、次の機能から最後まで行く。

90
00:06:56.470 --> 00:07:02.340
それから我々は、列を比較しようとすると、
我々は右に立っている2つの列。

91
00:07:02.340 --> 00:07:07.640
そして、彼らは要素が同じである場合、我々
は、列を重複している

92
00:07:07.640 --> 00:07:13.030
そして、基本的にはどのように重複した列の
この辞書を埋めることです。

93
00:07:13.030 --> 00:07:18.300
ここでは、変数9が重複していることがわか
りました。

94
00:07:18.300 --> 00:07:22.310
入力8と変数18が重複しています。

95
00:07:22.310 --> 00:07:25.850
変数8などのように、我々は本当にここでの
重複がたくさんある。

96
00:07:27.900 --> 00:07:33.540
だから、このループは、いくつかの時間がか
かったので、私はダンプを好む

97
00:07:33.540 --> 00:07:38.550
ディスクへの結果は、私たちは簡単に復元す
ることができます。

98
00:07:38.550 --> 00:07:43.265
だから私はここでそれを行うと、私は基本的
にそれらの列をドロップ

99
00:07:43.265 --> 00:07:47.170
列車のテストデータフレームから見つけた

100
00:07:47.170 --> 00:07:51.330
そうです、2番目のビデオでは、

101
00:07:51.330 --> 00:07:56.131
我々はいくつかの機能を通過し、

102
00:07:56.131 --> 00:07:59.500
データセットにいくつかの作業を行います。

103
00:07:59.500 --> 00:08:09.500
音楽

