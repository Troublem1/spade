1
00:00:00.025 --> 00:00:05.349
音今、私は競争の特定についてお伝えします

2
00:00:05.349 --> 00:00:09.704
データリークと緊密に接続された技術。

3
00:00:09.704 --> 00:00:12.110
それはリーダーボードのプロービングです。

4
00:00:12.110 --> 00:00:14.970
実際には、2種類のリーダーボードプロービ
ングがあります。

5
00:00:14.970 --> 00:00:18.842
最初の1つは、単に公共の部分からすべての
地上の真理を抽出している

6
00:00:18.842 --> 00:00:20.670
スコアボード。

7
00:00:20.670 --> 00:00:25.030
これは通常、かなりのデータを負担するのは
、もう少し無害です。

8
00:00:25.030 --> 00:00:27.710
それも比較的やりやすいし、

9
00:00:27.710 --> 00:00:31.920
私はあなたができるように行の小さなセット
に提出の変更を持っている

10
00:00:31.920 --> 00:00:36.230
ランキングスコアからそれらの行のためのグ
ランド真実を明確に計算します。

11
00:00:37.310 --> 00:00:42.360
私は追加の資料でアレックトロットのポスト
へのリンクをチェックアウトすることをお勧
め。

12
00:00:42.360 --> 00:00:45.320
彼はそれを非常に効率的に行う方法を徹底的
に説明する

13
00:00:45.320 --> 00:00:47.180
提出の最小量で。

14
00:00:48.285 --> 00:00:52.585
私たちの主な焦点は、リーダーボードプロー
ビングの別のタイプになります。

15
00:00:52.585 --> 00:00:56.015
公共の、プライベートの分割の目的を覚えて
います。

16
00:00:56.015 --> 00:01:01.305
これは、情報の抽出からテストセットのプラ
イベート部分を保護することになっている。

17
00:01:01.305 --> 00:01:05.055
それはまだ脆弱であることがわかった。

18
00:01:05.055 --> 00:01:08.715
場合によっては、そのような方法で予測を提
出することが可能です

19
00:01:08.715 --> 00:01:12.640
これにより、プライベートデータに関する情
報が提供されます。

20
00:01:12.640 --> 00:01:14.817
それはすべての一貫したカテゴリについてで
す。

21
00:01:14.817 --> 00:01:19.750
想像すると、すべての行に同じターゲットを
持つデータの塊。

22
00:01:19.750 --> 00:01:24.920
例のように、同じ id
を持つ行は同じターゲットを持っています。

23
00:01:24.920 --> 00:01:28.080
主催者は、公共と民間の部品に分割します。

24
00:01:29.120 --> 00:01:35.280
しかし、我々はまだその特定のチャンクは、
すべての役割のために同じラベルを持ってい
ることを知っている。

25
00:01:35.280 --> 00:01:38.980
すべての予測を0に近い設定した後、私たち
の提出のための

26
00:01:38.980 --> 00:01:43.870
データのその特定のチャンクは、我々は2つ
の結果を期待することができます。

27
00:01:43.870 --> 00:01:50.180
最初の1つは、スコアが改善されたとき、そ
れは公共の場の真理は0であることを意味し
ます。

28
00:01:50.180 --> 00:01:54.750
そして、それはまた、プライベートでの地上
の真実も0であることを意味します。

29
00:01:54.750 --> 00:01:57.670
私たちのチャンクは、同じラベルを持って覚
えておいてください。

30
00:01:58.670 --> 00:02:02.210
2番目の結果は、スコアが悪化したときです
。

31
00:02:02.210 --> 00:02:09.060
同様に、それは公共および私用両方の地上の
真実が1であることを意味する。

32
00:02:09.060 --> 00:02:12.760
いくつかの大会は確かにカテゴリのようなも
のがあります。

33
00:02:12.760 --> 00:02:16.270
高い確実性を持つカテゴリは、同じラベルを
持っています。

34
00:02:17.290 --> 00:02:21.960
あなたは、Red Hat のカテゴリのこ
れらのタイプに遭遇した可能性があります

35
00:02:21.960 --> 00:02:23.860
西ナイル大会。

36
00:02:23.860 --> 00:02:24.970
勝つためのカギだった。

37
00:02:26.050 --> 00:02:30.330
応募の多くは、1つのプライベートテストセ
ットの良い部分を探ることができます。

38
00:02:31.600 --> 00:02:34.770
それはおそらく、データリークの最も厄介な
タイプです。

39
00:02:34.770 --> 00:02:39.330
それはほとんどの技術であっても、それは競
争の近くにリリースされている場合

40
00:02:39.330 --> 00:02:44.190
締め切りは、単に十分な提出を完全にそれを
悪用する必要はありません。

41
00:02:45.240 --> 00:02:48.790
さらに、これは氷山の一角にあります。

42
00:02:48.790 --> 00:02:51.380
私は一貫したカテゴリを言うとき、

43
00:02:51.380 --> 00:02:56.330
私は必ずしもこのカテゴリは、同じターゲッ
トを持っているわけではありません。

44
00:02:56.330 --> 00:03:00.500
それは異なった方法で一貫していることがで
きる。

45
00:03:00.500 --> 00:03:02.280
定義はかなり広いです。

46
00:03:02.280 --> 00:03:07.190
たとえば、ターゲットラベルは、単にパブリ
ックと

47
00:03:07.190 --> 00:03:09.440
データのプライベート部分。

48
00:03:09.440 --> 00:03:13.080
それは Quora
の質問の組の競争の場合だった。

49
00:03:13.080 --> 00:03:16.770
その競争ではバイナリの分類があった

50
00:03:16.770 --> 00:03:20.370
ログ損失メトリックによって評価されるタス
ク。

51
00:03:20.370 --> 00:03:25.150
重要な目標は、電車の中で異なる分布を持っ
ていたことができた

52
00:03:25.150 --> 00:03:30.120
テストが、伝えられるところでは、これらの
データの同じ、民間および公共の部分。

53
00:03:30.120 --> 00:03:35.370
そして、そのため、我々はリーダーボードプ
ロービングを介して多くの恩恵を受けること
ができます。

54
00:03:35.370 --> 00:03:39.690
テストセット全体を一貫したカテゴリとして
扱います。

55
00:03:39.690 --> 00:03:42.378
スライドの数式を見てください。

56
00:03:42.378 --> 00:03:47.608
定数予測 C
ビッグで提出のためのこの対数損失。

57
00:03:47.608 --> 00:03:52.064
ここで、N big は、実際の行の数は、

58
00:03:52.064 --> 00:03:57.708
N1 big
は、ターゲット1の行数です。

59
00:03:57.708 --> 00:04:02.970
そして L big はその一定した予言に
よって与えられるリーダーの板スコアである
。

60
00:04:02.970 --> 00:04:07.990
この式から n1 を N
で割った値を計算することができます。

61
00:04:07.990 --> 00:04:13.250
つまり、テストセットにおける1回の真の比
率です。

62
00:04:13.250 --> 00:04:15.860
その知識は非常に有益だった。

63
00:04:15.860 --> 00:04:19.130
我々はそれを使用することができますリバラ
ンストレーニングデータポイント

64
00:04:19.130 --> 00:04:23.750
テストセットと同じターゲット変数の分布を
持つようにします。

65
00:04:23.750 --> 00:04:28.300
この小さなトリックは、リーダーボードのス
コアで大きな後押しを与えた。

66
00:04:28.300 --> 00:04:32.560
ご覧のように、リーダーボードのプロービン
グは非常に深刻な問題です

67
00:04:32.560 --> 00:04:36.730
それは多くの異なる状況下で発生する可能性
があります。

68
00:04:36.730 --> 00:04:40.800
私はいつかそれが完全に競争から根絶になる
ことを願って

69
00:04:40.800 --> 00:04:41.620
機械学習。

70
00:04:42.830 --> 00:04:46.745
さて、最後に、私は簡単に最も独特のを歩く
ように

71
00:04:46.745 --> 00:04:49.500
データ漏洩で面白い大会。

72
00:04:50.530 --> 00:04:51.140
そしてまず、

73
00:04:51.140 --> 00:04:55.540
別の視点から真のネイティブの競争を見てみ
ましょう。

74
00:04:55.540 --> 00:05:00.450
この大会では、参加者は、コンテンツかどう
かを予測するように求められた

75
00:05:00.450 --> 00:05:05.360
HTML ファイルでは、スポンサーされて
いるかどうか。

76
00:05:05.360 --> 00:05:09.690
既に前のビデオで説明したように、

77
00:05:09.690 --> 00:05:12.760
アーカイブの日付にデータリークが発生しま
した。

78
00:05:12.760 --> 00:05:14.765
我々は、スポンサーと仮定することができま
す

79
00:05:14.765 --> 00:05:18.890
非スポンサーの HTML ファイルは、時
間の異なる期間中に得られた。

80
00:05:20.310 --> 00:05:25.310
だから私たちは本当にアーカイブの日付を消
去した後、データリークを取り除くのですか
?

81
00:05:26.740 --> 00:05:28.300
答えはノーです。

82
00:05:28.300 --> 00:05:33.870
HTML ファイル内のテキストは、多くの
方法で日付に接続されている可能性がありま
す。

83
00:05:33.870 --> 00:05:40.330
ニュースの内容のように、明示的なタイムス
タンプから、はるかに細かいことまで。

84
00:05:40.330 --> 00:05:42.720
おそらく既に実現しているように、

85
00:05:42.720 --> 00:05:49.020
実際の問題は、メタデータリークではなく、
データ収集でした。

86
00:05:49.020 --> 00:05:51.000
メタ情報なくても、

87
00:05:51.000 --> 00:05:55.930
機械学習アルゴリズムは、実際には無駄な機
能に焦点を当てる。

88
00:05:55.930 --> 00:05:59.730
日付のプロキシとしてのみ動作する機能。

89
00:06:00.780 --> 00:06:06.330
次の例では、エクスペディアホテルの推奨事
項は、

90
00:06:06.330 --> 00:06:12.800
そして、その大会は、参加者の顧客の行動の
ログで働いた。

91
00:06:12.800 --> 00:06:18.370
これらは、検索結果とどのように相互作用し
たか、お客様が検索を含む

92
00:06:18.370 --> 00:06:23.340
クリックまたは書籍、および検索結果が旅行
パッケージであるかどうか。

93
00:06:24.630 --> 00:06:30.250
エクスペディアは、ユーザーが予約しようと
しているホテルグループを予測することに興
味を持っていた。

94
00:06:31.260 --> 00:06:35.975
顧客の行動のログ内には、非常にトリッキー
な機能があった。

95
00:06:35.975 --> 00:06:39.590
ホテルを求めるユーザーからの距離で。

96
00:06:39.590 --> 00:06:44.010
、この機能は、実際には巨大なデータリーク
が判明した。

97
00:06:44.010 --> 00:06:49.140
この距離を使って、2つの座標をリバースエ
ンジニアリングすることができ、

98
00:06:49.140 --> 00:06:52.780
列車セットからテストセットに地上の真実を
単にマップしなさい。

99
00:06:53.920 --> 00:06:57.400
私は強く、特別なビデオをチェックアウトす
ることをお勧め

100
00:06:57.400 --> 00:06:59.970
この競争に捧げた。

101
00:06:59.970 --> 00:07:03.650
私はあなたが非常に便利なので、アプローチ
と見つけることを期待

102
00:07:03.650 --> 00:07:08.160
データリークを利用する方法は非常に複雑で
した。

103
00:07:08.160 --> 00:07:10.970
そして、あなたはそれに多くの興味深いトリ
ックを見つけるでしょう。

104
00:07:12.120 --> 00:07:16.400
次の例では、物理学の競争の味からです。

105
00:07:16.400 --> 00:07:19.990
それは物理学を扱うかなり複雑な問題だった

106
00:07:19.990 --> 00:07:21.515
大型ハドロン衝突加速器。

107
00:07:21.515 --> 00:07:26.241
その競争についての特別なことは、

108
00:07:26.241 --> 00:07:30.730
信号は人工的にシミュレートされました。

109
00:07:30.730 --> 00:07:34.230
主催者は、マシンの学習ソリューションを望
んでいた

110
00:07:34.230 --> 00:07:38.140
何かが観察されたことがない。

111
00:07:38.140 --> 00:07:39.970
だから信号がシミュレートされた

112
00:07:41.250 --> 00:07:46.770
しかし、シミュレーションを完璧にすること
はできませんし、それをリバースエンジニア
リングすることが可能です。

113
00:07:46.770 --> 00:07:50.230
主催者も特別な統計テストを作成

114
00:07:50.230 --> 00:07:54.830
ためには、シミュレーションの欠陥を悪用す
るモデルを処罰する。

115
00:07:54.830 --> 00:07:57.298
しかし、それは無駄だった。

116
00:07:57.298 --> 00:08:01.870
1つは、テストをバイパスする可能性が完全
にシミュレーションの欠陥を悪用し、

117
00:08:01.870 --> 00:08:04.980
スコアボードで満点をゲット。

118
00:08:04.980 --> 00:08:08.240
最後の例では、一対一のタスクについて説明
します。

119
00:08:08.240 --> 00:08:12.850
1つは、特定のペアのかどうかを予測する必
要があります

120
00:08:12.850 --> 00:08:17.580
アイテムが重複しているかどうか、Quor
a の質問のペアの競争のように。

121
00:08:18.780 --> 00:08:23.830
一対一のタスクを持つすべての大会に共通す
る1つの事があります。

122
00:08:23.830 --> 00:08:28.440
参加者は、すべての可能なペアを評価するよ
う求められません。

123
00:08:28.440 --> 00:08:32.400
常にいくつかの確率サブサンプリング周期が
あり、

124
00:08:32.400 --> 00:08:36.280
このサブサンプリング周期はデータ漏洩の原
因です。

125
00:08:36.280 --> 00:08:40.850
通常、主催者のサンプルは、主にペアを区別
するのは難しい。

126
00:08:40.850 --> 00:08:46.040
そのため、もちろん、アイテムの周波数の不
均衡。

127
00:08:46.040 --> 00:08:50.000
それはより頻繁な項目でより高いを持ってい
る結果

128
00:08:50.000 --> 00:08:52.470
重複する可能性があります。

129
00:08:52.470 --> 00:08:54.230
でもそれだけじゃないんです。

130
00:08:54.230 --> 00:08:57.740
我々は、n 回 n
の接続行列を作成することができます

131
00:08:57.740 --> 00:09:01.180
ここで、N はアイテムの総数です。

132
00:09:01.180 --> 00:09:07.066
項目 i および項目 J
が組で現われたら私達は I で1を置き、

133
00:09:07.066 --> 00:09:10.060
j と j、私の位置。

134
00:09:10.060 --> 00:09:15.480
これで、接続行列の行をベクトル表現として
扱うことができます。

135
00:09:15.480 --> 00:09:17.040
すべての項目。

136
00:09:17.040 --> 00:09:21.720
これは、これらのベクトル間の類似性を計算
できることを意味します。

137
00:09:21.720 --> 00:09:24.360
このトリックは非常に単純な理由で動作しま
す。

138
00:09:25.420 --> 00:09:29.480
2つの項目に類似した近隣ノードがある場合

139
00:09:29.480 --> 00:09:32.980
彼らは重複している可能性が高い。

140
00:09:34.160 --> 00:09:36.260
これは、データリークが発生しています。

141
00:09:36.260 --> 00:09:40.980
私はあなたのコンセプトを得たと興味深い例
をたくさん発見願っています。

142
00:09:40.980 --> 00:09:42.315
ご注意をありがとうございました。

143
00:09:42.315 --> 00:09:52.315
音

