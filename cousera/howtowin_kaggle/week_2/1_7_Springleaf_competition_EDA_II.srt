1
00:00:03.070 --> 00:00:07.730
だから、探査を続けてみましょう。

2
00:00:07.730 --> 00:00:11.131
我々は、変数の種類を決定したい

3
00:00:11.131 --> 00:00:14.780
そして、我々は最初にこの nunique
関数を使用することを行うには

4
00:00:14.780 --> 00:00:18.574
機能が持つ一意の値の数を確認します。

5
00:00:18.574 --> 00:00:25.155
この dropna = False
を使用して、この関数が nons を計算
し、アカウントを作成することを確認します
。

6
00:00:25.155 --> 00:00:28.300
それ以外の場合は、一意の値として修道女カ
ウントされません。

7
00:00:28.300 --> 00:00:33.665
それはちょうどそれらを unhit
します。そのためには、ここでは、ID
を参照してください多くの

8
00:00:33.665 --> 00:00:40.545
ユニークな値を再度、その後、我々は右、こ
のシリーズのように巨大な値を持っていない
?

9
00:00:40.545 --> 00:00:47.981
だから私は15万の要素が6000ユニーク
な要素があります。

10
00:00:47.981 --> 00:00:52.065
25000、それは右、膨大な数ではないの
ですか?

11
00:00:52.065 --> 00:00:57.200
そのためには、この情報を集約し、上からの
値のヒストグラムを行うことができます。

12
00:00:57.200 --> 00:01:01.950
そして、それはこれらの正確な値のヒストグ
ラムではないが、それは正規化された値です
。

13
00:01:01.950 --> 00:01:06.725
したがって、各値をツリーの行数で除算しま
す。

14
00:01:06.725 --> 00:01:11.170
それは私達が多分持っていることができる一
義的な価値の最大値である。

15
00:01:11.170 --> 00:01:15.380
だから我々はここにある多くの機能があるこ
とを参照してください

16
00:01:15.380 --> 00:01:24.965
いくつかのユニークな値とは、多くのがいく
つかありますが、

17
00:01:24.965 --> 00:01:26.330
でもそれほどでもなく、

18
00:01:26.330 --> 00:01:28.280
これほどでもない

19
00:01:28.280 --> 00:01:34.425
したがって、これらの機能は、ほぼすべての
行に一意の値があります。

20
00:01:34.425 --> 00:01:39.080
では、実際にこれらを探ってみましょう。

21
00:01:39.080 --> 00:01:44.945
したがって、ID は本質的に多くのユニー
クな値を持っています。

22
00:01:44.945 --> 00:01:47.775
それは問題ありません。しかし、これは何で
すか?

23
00:01:47.775 --> 00:01:52.160
ここで実際に見るのは整数です。

24
00:01:52.160 --> 00:01:54.705
彼らは膨大な数ですが、彼らは整数だ。

25
00:01:54.705 --> 00:01:59.480
まあ、私は本物を期待するだろう、

26
00:01:59.480 --> 00:02:04.865
実際の値を持つ変数を nunique
には、ユニークな値をたくさん持って、

27
00:02:04.865 --> 00:02:08.320
整数型の変数ではありません。

28
00:02:08.320 --> 00:02:14.090
では、これらの変数が何を表しているのでし
ょうか。

29
00:02:14.090 --> 00:02:16.109
基本的には、やはりカウンターでもかまいま
せん。

30
00:02:16.109 --> 00:02:18.680
でも他に何があるの?

31
00:02:18.680 --> 00:02:23.505
これは、ミリ秒または ns
のようなものを言うの時間かもしれない。

32
00:02:23.505 --> 00:02:29.514
そして、我々は、値の間に重複しないユニー
クな値の多くを持っている

33
00:02:29.514 --> 00:02:33.020
本当にありそうにないので

34
00:02:33.020 --> 00:02:37.430
我々のデータセットの2つのイベントまたは
2つの行は、同じ時間を持つ

35
00:02:37.430 --> 00:02:39.705
それは創造の時などと言ってみましょう

36
00:02:39.705 --> 00:02:44.215
時間精度がかなり良いので。

37
00:02:44.215 --> 00:02:47.920
そう、それは我々の推測かもしれない。

38
00:02:47.920 --> 00:02:51.315
次に、この機能のグループを探ってみましょ
う。

39
00:02:51.315 --> 00:02:53.320
再びいくつかの操作で、

40
00:02:53.320 --> 00:02:57.035
私はそれらを見つけ、これらは、この表で紹
介されています。

41
00:02:57.035 --> 00:02:59.600
何が面白い?

42
00:02:59.600 --> 00:03:01.740
実際には、名前を見てみると。

43
00:03:01.740 --> 00:03:05.380
だから、最初の1つは541です。そして、
2つ目は543です。

44
00:03:05.380 --> 00:03:07.920
大丈夫です。

45
00:03:07.920 --> 00:03:11.096
そして、我々は1081と1082を持って
、

46
00:03:11.096 --> 00:03:16.445
だから、彼らは本当にお互いに近くに立って
いる参照してください。

47
00:03:16.445 --> 00:03:19.897
それは本当に行の半分は、そうだ

48
00:03:19.897 --> 00:03:23.488
列の順序がランダムだった場合、列がシャッ
フルされた場合。

49
00:03:23.488 --> 00:03:28.095
したがって、おそらく列が一緒にグループ化
されている

50
00:03:28.095 --> 00:03:33.275
何かによると、我々はこの何かを探ることが
できます。

51
00:03:33.275 --> 00:03:35.130
そして、何より興味深いのは、

52
00:03:35.130 --> 00:03:38.820
我々は1つの行に対応する値を見てみると、

53
00:03:38.820 --> 00:03:42.400
次に、この値がこの値と等しいと言うことが
わかります。

54
00:03:42.400 --> 00:03:44.030
この値はこの値とこの値と等しくなり、

55
00:03:44.030 --> 00:03:47.760
そして、これは基本的に我々がここで持って
いたのと同じ値です。

56
00:03:47.760 --> 00:03:52.715
だから、我々は4つのうち、同じ値を持つ5
つの機能があります。

57
00:03:52.715 --> 00:03:56.025
また、他のオブジェクトを調べる場合は、

58
00:03:56.025 --> 00:04:00.370
それらのいくつかは、同じことが起こってい
るだろうといくつかはありません。

59
00:04:00.370 --> 00:04:06.105
だから、あなたはそれが本当に不可欠なもの
かもしれない参照してください

60
00:04:06.105 --> 00:04:12.270
オブジェクトとそれは、互いにオブジェクト
を分ける素晴らしい機能かもしれません。

61
00:04:12.270 --> 00:04:15.990
そして、それは私たちがすべきものだ

62
00:04:15.990 --> 00:04:20.520
実際に調査し、我々は実際にいくつかの機能
工学を行う必要があります。

63
00:04:20.520 --> 00:04:23.010
なので、「聞こえない」と仰るために、

64
00:04:23.010 --> 00:04:25.440
これらのパターンを見つけるのは本当に難し
いでしょう。

65
00:04:25.440 --> 00:04:26.695
つまり見つけられない

66
00:04:26.695 --> 00:04:33.375
まあ、それは2つの機能が等しいか、5つの
機能が等しいことを見つけるのに苦労します
。

67
00:04:33.375 --> 00:04:40.315
だから、我々が作成するか、またはこれらの
うち、どのように多くの機能を計算する機能
を言う

68
00:04:40.315 --> 00:04:45.150
我々は同じ値を持っているどのように多くの
機能が言う

69
00:04:45.150 --> 00:04:47.450
オブジェクト0では、値5が

70
00:04:47.450 --> 00:04:50.724
この機能と他の行のために何か、

71
00:04:50.724 --> 00:04:54.885
その後、おそらくこの機能を識別することが
できます。

72
00:04:54.885 --> 00:04:56.710
その後、我々は他の機能を作成することがで
きます

73
00:04:56.710 --> 00:05:02.005
この列の値が1に設定されているとします。

74
00:05:02.005 --> 00:05:06.780
これとこれとこれとこれとこれは、そうでな
ければ、とゼロと同じです。

75
00:05:06.780 --> 00:05:09.060
そして基本的には、これらの行を通過する場
合は、

76
00:05:09.060 --> 00:05:11.580
あなたは、パターンが異なっていることがわ
かります

77
00:05:11.580 --> 00:05:15.805
異なる列の値が同じ場合があります。

78
00:05:15.805 --> 00:05:17.655
たとえば、この行では、

79
00:05:17.655 --> 00:05:20.385
この値がこの値と等しいことがわかります。

80
00:05:20.385 --> 00:05:26.100
そして、この値は、以前のものには異なるが
、この1つに等しい。

81
00:05:26.100 --> 00:05:29.120
そして、それは本当に魅力的ですね。

82
00:05:29.120 --> 00:05:32.130
そして、それが実際に動作し、モデルを改善
する場合、

83
00:05:32.130 --> 00:05:34.540
私は幸せになります。

84
00:05:34.540 --> 00:05:41.550
そして、我々はここを参照してくださいもう
一つは、いくつかの奇妙な値であり、彼らは
nons のように見える。

85
00:05:41.550 --> 00:05:47.715
つまり人間が入力したものかマシンが
autofilled したものだ

86
00:05:47.715 --> 00:05:52.720
だから、さらに行きましょう。ああ、そうで
す。

87
00:05:52.720 --> 00:05:55.915
そして、最後のものを選択しようとするだけ
です

88
00:05:55.915 --> 00:06:00.040
このグループの変数の1つで、どの値がある
かを確認します。

89
00:06:00.040 --> 00:06:04.773
だから、変数15を選択してみましょうここ
では、その値です。

90
00:06:04.773 --> 00:06:10.975
とマイナス999は、おそらく我々は
nons に記入した方法です。

91
00:06:10.975 --> 00:06:15.200
そして、はい、我々はそれらの56を持って
おり、他のすべての値は、非負の

92
00:06:15.200 --> 00:06:17.295
だから、おそらくそれはカウンタです。

93
00:06:17.295 --> 00:06:21.115
何が起こったかというと

94
00:06:21.115 --> 00:06:23.230
私は、月またはそのようなもので、わからな
い。

95
00:06:23.230 --> 00:06:25.835
大丈夫です。

96
00:06:25.835 --> 00:06:27.755
そして最後に

97
00:06:27.755 --> 00:06:34.305
列をフィルタしてから、列をカテゴリと数値
に分けてみましょう。

98
00:06:34.305 --> 00:06:38.255
そして、それは本当にこの関数
select_dtypes
を使用して行うのは簡単です。

99
00:06:38.255 --> 00:06:44.525
基本的には、オブジェクト型を持つすべての
列、

100
00:06:44.525 --> 00:06:48.510
関数 dtypes を使用する場合。

101
00:06:48.510 --> 00:06:51.070
我々は、カテゴリ変数と考えています。

102
00:06:51.070 --> 00:06:55.340
それ以外の場合は、型の整数または
float またはそのようなものが割り当
てられている場合は、

103
00:06:55.340 --> 00:07:01.015
または数値型これらの列を数値列として考え
ます。

104
00:07:01.015 --> 00:07:08.615
だから、私たちの機能を1つずつ、実際に私
は競争の中で行ったことができます。

105
00:07:08.615 --> 00:07:12.730
さて、我々は、このデータセットの2000
機能を持っている

106
00:07:12.730 --> 00:07:19.340
特徴を1つずつ通すのはたまらない。

107
00:07:19.340 --> 00:07:23.190
私は約250の機能で停止しました。

108
00:07:23.190 --> 00:07:26.876
あなたが興味を持っている場合、あなたは私
のノート pc
と読み物で見つけることができます。

109
00:07:26.876 --> 00:07:31.280
ちょっと散らかってるけど見てていいよ。だ
から

110
00:07:31.280 --> 00:07:33.636
ここでは、

111
00:07:33.636 --> 00:07:39.500
私はデータセットで調査しようとしていたも
ののほんのいくつかの例では、

112
00:07:39.500 --> 00:07:40.823
次のようにしましょう。

113
00:07:40.823 --> 00:07:43.983
列数を取りましょう、

114
00:07:43.983 --> 00:07:46.665
我々は以前にそれらを計算した。

115
00:07:46.665 --> 00:07:53.625
そこで、最初の42列のみを使用して、この
ようなメトリックスを作成します。

116
00:07:53.625 --> 00:07:58.240
そして、それは相関行列とそのタイプのすべ
てのように見えます

117
00:07:58.240 --> 00:08:03.130
y 軸に沿ってフィーチャを持つ場合のよう
な行列

118
00:08:03.130 --> 00:08:05.080
x 軸に沿ったフィーチャ。

119
00:08:05.080 --> 00:08:06.975
基本的に、まあ、それは本当に巨大です。

120
00:08:06.975 --> 00:08:09.260
うん。そしてこの場合、

121
00:08:09.260 --> 00:08:14.185
値として必要なのは、数値または分数です。

122
00:08:14.185 --> 00:08:19.430
2番目のフィーチャーの要素より大きい1つ
のフィーチャーの要素。

123
00:08:19.430 --> 00:08:25.825
したがって、たとえば、このセルはすべての
変数またはすべての値を示します。

124
00:08:25.825 --> 00:08:34.100
変数50では、予想される値と変数 ID
よりも小さくなります。

125
00:08:34.100 --> 00:08:35.790
だから、はい。

126
00:08:35.790 --> 00:08:36.940
ここは正反対だ

127
00:08:36.940 --> 00:08:41.995
だから、我々はここで1つを参照してくださ
い場合は、変数45を意味する

128
00:08:41.995 --> 00:08:45.290
たとえば、常に変数24より大きいです。

129
00:08:45.290 --> 00:08:50.810
そして、我々はこのメトリックは何とかラン
ダムになることを期待しながら、

130
00:08:50.810 --> 00:08:54.755
カウントの順序がランダムだった場合。

131
00:08:54.755 --> 00:08:56.568
しかし、ここで我々は、参照してください

132
00:08:56.568 --> 00:08:58.935
たとえば、正方形のこれらの種類。

133
00:08:58.935 --> 00:09:03.068
これは、すべての2番目の機能が大きいこと
を意味

134
00:09:03.068 --> 00:09:08.725
2番目にではなく、私は + 1
機能は、機能 i
よりも大きいとしましょう。

135
00:09:08.725 --> 00:09:13.300
そして、まあそれは、この情報については、
可能性があります

136
00:09:13.300 --> 00:09:17.825
たとえば、時間の異なる期間のカウンタ。

137
00:09:17.825 --> 00:09:23.620
したがって、たとえば、最初の機能は、最初
の月に発生したイベントの数です。

138
00:09:23.620 --> 00:09:25.795
2番目の機能は、どのように多くのイベント
が起こった

139
00:09:25.795 --> 00:09:30.910
最初の2ヶ月と累積値のような種類。

140
00:09:30.910 --> 00:09:34.925
そして、その理由は、1つの機能は、常に他
のよりも大きいです。

141
00:09:34.925 --> 00:09:41.125
そして、基本的に、どのような情報を抽出す
ることができます

142
00:09:41.125 --> 00:09:44.365
この種の指標から、我々はこのグループを持
っているということです

143
00:09:44.365 --> 00:09:48.520
そして、我々は、新しい機能を生成すること
ができますこれらの機能は、

144
00:09:48.520 --> 00:09:51.795
たとえば、2つの連続する機能の違い。

145
00:09:51.795 --> 00:09:54.760
それは我々が抽出する方法です,
例えば、,

146
00:09:54.760 --> 00:09:58.695
毎月のイベント数。

147
00:09:58.695 --> 00:10:04.615
そのため、累積値から通常の値に戻ります。

148
00:10:04.615 --> 00:10:08.380
そして、よく線形モデル、言う、ニューラル
ネットワーク、

149
00:10:08.380 --> 00:10:13.710
彼らはそれ自身が、ツリーベースのアルゴリ
ズムはできませんでした。

150
00:10:13.710 --> 00:10:16.445
だから、それは本当に役立つ可能性がありま
す。

151
00:10:16.445 --> 00:10:22.105
だから、に添付されて

152
00:10:22.105 --> 00:10:27.380
読書材料の非本は、パターンの多くは、これ
らの種類が表示されます。

153
00:10:27.380 --> 00:10:29.990
だからここに1人いる

154
00:10:29.990 --> 00:10:36.810
パターン、まあ、これもパターンですよね。

155
00:10:36.810 --> 00:10:44.415
そして今、私たちは、異なっているいくつか
の変数を通過します。

156
00:10:44.415 --> 00:10:49.940
したがって、たとえば、変数2と変数3が面
白いです。

157
00:10:49.940 --> 00:10:54.060
あなたはそれらのヒストグラムを構築する場
合は、

158
00:10:54.060 --> 00:10:56.820
あなたはそのようなものが表示されます。

159
00:10:56.820 --> 00:11:00.390
そして、ここで最も興味深い部分は、これら
のスパイクです。

160
00:11:00.390 --> 00:11:04.715
そして、あなたは、再び、彼らはランダムで
はない参照してください。

161
00:11:04.715 --> 00:11:06.865
何かあるわ

162
00:11:06.865 --> 00:11:12.520
だから、我々はこの変数を2つを取るとそこ
に構築する場合、まあ、

163
00:11:12.520 --> 00:11:14.541
この値カウントの関数を使用して、

164
00:11:14.541 --> 00:11:19.030
この変数には、値と回数が発生します。

165
00:11:19.030 --> 00:11:21.960
我々は、値が表示されます, トップの値,

166
00:11:21.960 --> 00:11:25.482
は 12, 24, 36,

167
00:11:25.482 --> 00:11:26.730
60のように。

168
00:11:26.730 --> 00:11:31.975
だから、彼らは12でも、おそらく分割する
ことができます

169
00:11:31.975 --> 00:11:36.550
この変数は時間に何とか繋がっていますよね
。

170
00:11:36.550 --> 00:11:39.660
時間に。

171
00:11:39.660 --> 00:11:42.105
それでどうするの?

172
00:11:42.105 --> 00:11:45.990
我々は、我々は価値のような機能を生成する
ように機能を生成したい

173
00:11:45.990 --> 00:11:50.670
これらの可変モジュール12または

174
00:11:50.670 --> 00:11:56.135
たとえば、この可変整数除算の値は12です
。

175
00:11:56.135 --> 00:11:58.900
だから、これは本当に役立つ可能性がありま
す。

176
00:11:58.900 --> 00:12:06.945
他の競争では、変数を構築し、再びそのよう
なものを参照することができます。

177
00:12:06.945 --> 00:12:08.495
そこで何が起こったのか

178
00:12:08.495 --> 00:12:11.260
主催者は、実際にデータを量子化した。

179
00:12:11.260 --> 00:12:16.515
だから、彼らは私たちの場合には12で割る
ことができるデータを持っていた。

180
00:12:16.515 --> 00:12:18.930
12、24などと言います。

181
00:12:18.930 --> 00:12:24.320
しかし、彼らは、おそらくデータを難読化の
種類にしたいと、彼らはいくつかのノイズを
追加しました。

182
00:12:24.320 --> 00:12:29.345
そのため、ヒストグラムをプロットすると、

183
00:12:29.345 --> 00:12:38.730
あなたはまだスパイクが表示されますが、ま
た、スパイクの間に何かが表示されます。

184
00:12:38.730 --> 00:12:42.500
そして、再び、その競争の中でこれらの機能
は、彼らは非常にうまく機能し、あなた

185
00:12:42.500 --> 00:12:49.010
値を dequantize ことができ、
それは本当に役立つ可能性があります。

186
00:12:49.010 --> 00:12:53.665
そして、同じことは基本的に変数3で起こっ
ている、

187
00:12:53.665 --> 00:12:55.540
0、12、24など。

188
00:12:55.540 --> 00:12:59.730
と変数4、私は持っていない

189
00:12:59.730 --> 00:13:05.705
ここで変数4自体の任意のプロットが、実際
に我々は同じことを行う。

190
00:13:05.705 --> 00:13:07.080
だから、我々は、変数4を取る

191
00:13:07.080 --> 00:13:12.620
我々は、新しい機能変数4モジュラス50を
作成します。

192
00:13:12.620 --> 00:13:17.570
そして今、我々は、ヒストグラムのこの種の
プロット。

193
00:13:17.570 --> 00:13:21.178
ここで見たものは薄緑色で、

194
00:13:21.178 --> 00:13:23.835
そこには実際に2つのヒストグラムがありま
す。

195
00:13:23.835 --> 00:13:25.990
クラス0からのオブジェクトの最初のものと

196
00:13:25.990 --> 00:13:29.665
クラス1からのオブジェクトの2番目の1。

197
00:13:29.665 --> 00:13:35.950
そして、1つはライトグリーンで描かれてお
り、2つ目は濃い緑色です。

198
00:13:35.950 --> 00:13:38.890
そして、あなたはこれらの他の値を参照して
ください。

199
00:13:38.890 --> 00:13:44.639
そして、あなたはこれらのバーの違いだけを
参照してください、

200
00:13:44.639 --> 00:13:45.980
しかし、あなたは違いを参照してください。

201
00:13:45.980 --> 00:13:49.550
つまり、これらの新しい機能変数

202
00:13:49.550 --> 00:13:55.160
4モジュラス50は、値0を取るときに、本
当に識別することができます。

203
00:13:55.160 --> 00:14:01.240
だから、1つは、このようなものだと言うこ
とができる、

204
00:14:01.240 --> 00:14:04.541
まあ、どう言っていいかわかりませんが、

205
00:14:04.541 --> 00:14:07.310
つまり、特定の人々は決してそれをしないだ
ろう。

206
00:14:07.310 --> 00:14:10.875
と同様に、なぜ我々は、モジュラー50を奪
うしたいですか?

207
00:14:10.875 --> 00:14:14.140
しかし、あなたは時々これは本当に役立つこ
とを参照してください。

208
00:14:14.140 --> 00:14:19.340
おそらく主催者がデータをそのように準備す
るので。

209
00:14:19.340 --> 00:14:25.235
そのためには、カテゴリの機能を介して取得
してみましょう。

210
00:14:25.235 --> 00:14:28.100
我々は、実際にそれらの多くはありません。

211
00:14:28.100 --> 00:14:34.845
ここにいくつかのラベル、いくつかのバイナ
リ変数があります。

212
00:14:34.845 --> 00:14:36.617
何だかわからないけど

213
00:14:36.617 --> 00:14:40.225
これはおそらく私が持っているエンコーディ
ングにいくつかの問題です。

214
00:14:40.225 --> 00:14:42.710
そして、いくつかの時間変数があります。

215
00:14:42.710 --> 00:14:45.385
これは、実際には時間ではありません。

216
00:14:45.385 --> 00:14:47.450
時間。時間じゃない

217
00:14:47.450 --> 00:14:49.530
時間じゃない時間だ

218
00:14:49.530 --> 00:14:50.880
おっと、これは面白いです。

219
00:14:50.880 --> 00:14:53.080
これは都市のようだね?

220
00:14:53.080 --> 00:14:55.025
町とか街の名前とか

221
00:14:55.025 --> 00:14:58.570
また、地理位置情報から生成できる機能を覚
えている場合は、

222
00:14:58.570 --> 00:15:01.355
それを生成する場所です。

223
00:15:01.355 --> 00:15:02.980
そして、もう一度、それはいくつかの時間だ
った

224
00:15:02.980 --> 00:15:07.980
いくつかのラベルともう一度、

225
00:15:07.980 --> 00:15:10.185
州だそうでしょう。

226
00:15:10.185 --> 00:15:15.855
だから、再び、我々はいくつかの地理的特徴
を生成することができます。

227
00:15:15.855 --> 00:15:22.200
しかし、特に興味深い、機能は日付です。

228
00:15:22.200 --> 00:15:24.420
ここにあった日付

229
00:15:24.420 --> 00:15:31.095
そして基本的に、これらは私がデータ情報を
持っていることがわかったすべての列です。

230
00:15:31.095 --> 00:15:37.745
だから、それは実際にこの競争のための最高
の機能の一つであった。

231
00:15:37.745 --> 00:15:39.255
次のようにすることができます。

232
00:15:39.255 --> 00:15:40.970
あなたの間に散布図を行うことができます

233
00:15:40.970 --> 00:15:48.350
特定の日付の機能に2つの日付の機能と、彼
らはいくつかの関係を持っていることがわか
った

234
00:15:48.350 --> 00:15:51.500
そして、1つは常に別のより大きい。

235
00:15:51.500 --> 00:15:55.475
それはおそらくこれらはいくつかのイベント
の日付であることを意味し、

236
00:15:55.475 --> 00:16:00.365
1つのイベントは、常に最初の1つの後に起
こっている。

237
00:16:00.365 --> 00:16:05.115
だから、我々はこれらの2つの日付の違いの
ような異なる機能を抽出することができます
。

238
00:16:05.115 --> 00:16:06.360
そして、この大会では、

239
00:16:06.360 --> 00:16:08.190
それは本当にたくさん役立った。

240
00:16:08.190 --> 00:16:10.485
なので、必ず

241
00:16:10.485 --> 00:16:15.510
探索的データ分析とそのようなすべての強力
な機能を抽出します。

242
00:16:15.510 --> 00:16:17.895
それ以外の場合は、データを調べたくない場
合は、

243
00:16:17.895 --> 00:16:19.805
あなたはそのようなものを見つけることがで
きません。

244
00:16:19.805 --> 00:16:22.350
そして、それは本当に面白いです。

245
00:16:22.350 --> 00:16:24.970
だから、聞いてくれてありがとう。

