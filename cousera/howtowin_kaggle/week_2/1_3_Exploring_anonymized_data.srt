1
00:00:00.025 --> 00:00:05.992
音以前のビデオでは、我々はのためのデータ
を使用していた

2
00:00:05.992 --> 00:00:09.222
私たちは素晴らしい説明していた。

3
00:00:09.222 --> 00:00:12.250
つまり、我々は機能が何であるかを知ってい
た、と

4
00:00:12.250 --> 00:00:17.190
データは深刻な変更なしで、これらとして私
たちを与えられた。

5
00:00:17.190 --> 00:00:19.370
しかし、それは常にそうではありません。

6
00:00:19.370 --> 00:00:22.399
データは匿名、難読化することができます。

7
00:00:23.530 --> 00:00:27.270
このビデオでは、まず匿名データとは何かに
ついて説明し、

8
00:00:27.270 --> 00:00:29.880
なぜ主催者は、データを匿名することを決定
。

9
00:00:30.890 --> 00:00:35.540
そして次に、我々は競合他社がそれについて
何ができるかが表示されます。

10
00:00:35.540 --> 00:00:37.890
時には、データをデコードすることができま
す, または

11
00:00:37.890 --> 00:00:42.620
我々は推測しようとすることができない場合
は、何の機能の種類です。

12
00:00:42.620 --> 00:00:44.070
なので、話し合いに出ましょう。

13
00:00:45.220 --> 00:00:49.130
場合によっては、主催者は本当にいくつかの
情報を確認します。

14
00:00:49.130 --> 00:00:52.020
だから、彼らは競争のデータをエクスポート
する努力をする

15
00:00:52.020 --> 00:00:55.680
あなたがそれをしている間、1つは得ること
ができなかった方法で。

16
00:00:55.680 --> 00:00:57.460
しかし、すべての機能が保存され、

17
00:00:57.460 --> 00:01:00.886
機械モデルは、それが仕事をすることができ
るようになります。

18
00:01:00.886 --> 00:01:05.910
たとえば、ある企業がドキュメントの分類を
希望している場合、

19
00:01:05.910 --> 00:01:08.820
ドキュメントの内容を明らかにしたくありま
せん。

20
00:01:08.820 --> 00:01:12.980
これは、それらの単語のハッシュ値を持つす
べての単語の出現を置き換えることができま
す

21
00:01:12.980 --> 00:01:14.330
例のように、ここを参照してください。

22
00:01:15.360 --> 00:01:18.970
実際には、それは言葉の袋に基づいてモデル
のためのものを変更することはありません。

23
00:01:20.290 --> 00:01:23.940
私はすべてのデータとして匿名データを参照
します

24
00:01:23.940 --> 00:01:26.630
どの主催者が意図的に変更。

25
00:01:26.630 --> 00:01:29.990
それは完全に正しいではありませんが、私は
この文言を使用します

26
00:01:29.990 --> 00:01:31.020
任意の種類の変更。

27
00:01:32.110 --> 00:01:34.310
表形式データを使用した計算では、

28
00:01:34.310 --> 00:01:37.790
企業は、各列のストアの情報を非表示にしよ
うとすることができます。

29
00:01:37.790 --> 00:01:39.490
このデータセットを見てください。

30
00:01:39.490 --> 00:01:43.520
まず、機能に意味のある名前はありません。

31
00:01:43.520 --> 00:01:46.976
名前はいくつかのダミーに置き換えられます
, と

32
00:01:46.976 --> 00:01:50.797
我々は、列 x1 と x6 の値のような
いくつかのハッシュを参照してください。

33
00:01:50.797 --> 00:01:54.748
最も可能性の高い、主催者はいくつかの機密
データをハッシュすることを決めた。

34
00:01:54.748 --> 00:01:58.770
この場合、データの探索中に実行できること
がいくつかあります。

35
00:01:59.860 --> 00:02:02.358
まず、我々はデコードしようとすることがで
きますか

36
00:02:02.358 --> 00:02:05.680
匿名は、もちろん、法的な方法で、データを
解除します。

37
00:02:05.680 --> 00:02:10.040
つまり、我々は、機能の真の意味を推測しよ
うとすることができます。

38
00:02:10.040 --> 00:02:13.350
時々デ匿名はできませんが、

39
00:02:13.350 --> 00:02:17.780
私たちはほとんど確実に行うことができます
、機能の種類を推測することです

40
00:02:17.780 --> 00:02:21.440
数値、カテゴリなどに分けることができます
。

41
00:02:22.640 --> 00:02:27.040
次に、機能が互いにどのように関連している
かを調べることができます。

42
00:02:27.040 --> 00:02:30.850
フィーチャのペア間の特定の関係を指定する
ことも、

43
00:02:30.850 --> 00:02:35.140
我々は、機能が何らかの形でグループ化され
ているかどうかを把握しようとすることがで
きます。

44
00:02:36.990 --> 00:02:40.560
このビデオでは、我々は最初の問題に専念し
ます。

45
00:02:40.560 --> 00:02:43.810
次のビデオでは、視覚化ツールについて説明
します。

46
00:02:43.810 --> 00:02:48.260
我々は、個々の機能を探索するための両方を
使用することができます, と機能の関係.

47
00:02:49.375 --> 00:02:54.339
それが解読することが可能だった方法の例を
得ることができるようになりました

48
00:02:54.339 --> 00:03:00.050
1つのローカル競争の特徴の意味は私が参加
した。

49
00:03:00.050 --> 00:03:04.310
私が参加した競技についてお話ししたいと思
います。

50
00:03:04.310 --> 00:03:08.823
これは、地元の競争であり、主催者は文字通
り与えていない

51
00:03:08.823 --> 00:03:12.000
競合他社のデータセットに関する情報。

52
00:03:12.000 --> 00:03:18.340
彼らはちょうど競争のページにデータをダウ
ンロードするためのリンクを入れ、何もない
。

53
00:03:18.340 --> 00:03:21.209
まずはデータを読んでみて、

54
00:03:21.209 --> 00:03:26.422
基本的に私たちがここで見るものは、データ
が匿名であるということです。

55
00:03:26.422 --> 00:03:30.711
列名は x のようなもので、

56
00:03:30.711 --> 00:03:36.920
値はハッシュで、残りは数値です。

57
00:03:36.920 --> 00:03:40.832
しかし、よく我々は、彼らが何を意味するの
か分からない

58
00:03:40.832 --> 00:03:44.120
そして、基本的に我々は予測するものではあ
りません。

59
00:03:44.120 --> 00:03:48.080
我々は、それがマルチクラスの分類タスクで
あることを知っている

60
00:03:48.080 --> 00:03:50.160
そして、4つのラベルがあります。

61
00:03:51.510 --> 00:03:54.930
データの内容がわからない限り

62
00:03:54.930 --> 00:03:58.490
我々は、おそらく迅速なベースラインを構築
することができます。

63
00:03:58.490 --> 00:04:00.790
ランダムなフォレスト分類子をインポートし
てみましょう。

64
00:04:02.760 --> 00:04:07.080
はい、もちろん、我々のデータフレームから
ターゲットラベルをドロップする必要があり
ます

65
00:04:07.080 --> 00:04:09.320
そこに含まれているように。

66
00:04:09.320 --> 00:04:13.040
null
値をマイナス999で塗りつぶし、

67
00:04:13.040 --> 00:04:18.160
すべてのカテゴリ機能をエンコードしてみま
しょう。

68
00:04:18.160 --> 00:04:21.250
我々は、型を見て見つけることができます。

69
00:04:21.250 --> 00:04:22.720
データフレームのプロパティです。

70
00:04:22.720 --> 00:04:26.466
我々は、ラベルエンコーダでそれらをエンコ
ードし、

71
00:04:26.466 --> 00:04:31.234
それは、パンダから関数
factorize で行う方が簡単です。

72
00:04:31.234 --> 00:04:33.890
ランダムな森林分類器にデータを送りましょ
う。

73
00:04:35.150 --> 00:04:39.415
そして、機能の重要性をプロットしてみまし
ょう, と

74
00:04:39.415 --> 00:04:45.250
ここでは、機能 X8
は興味深いもののように見えます。

75
00:04:45.250 --> 00:04:49.950
我々は、おそらくそれを少し深く調査する必
要があります。

76
00:04:49.950 --> 00:04:53.779
我々は、機能 X8 を取る場合, と

77
00:04:53.779 --> 00:04:59.250
印刷は、それを意味し、値を推定する。

78
00:04:59.250 --> 00:05:04.360
彼らはかなり0に近いことが判明し、1それ
ぞれ、および

79
00:05:05.870 --> 00:05:10.470
この機能は、主催者によって応募熟練された
ように見えます。

80
00:05:10.470 --> 00:05:14.890
ここでは正確に0が表示、正確に1、

81
00:05:14.890 --> 00:05:18.810
おそらくトレーニングテストは、最新のスケ
ールで連結されたため。

82
00:05:18.810 --> 00:05:22.542
我々はトレーニングテストを連結する場合、
その後の平均は正確に0になります

83
00:05:22.542 --> 00:05:24.247
そして、std は正確に1になります。

84
00:05:29.343 --> 00:05:33.080
わかりましたので、また、これらの機能には
、他の繰り返し値が表示されますか?

85
00:05:33.080 --> 00:05:35.750
我々は、値カウント機能でそれを行うことが
できます。

86
00:05:35.750 --> 00:05:39.128
最初の15行分の値を出力してみましょう。

87
00:05:40.260 --> 00:05:43.740
そして、繰り返される価値観がたくさんある
のはわかりますが、

88
00:05:45.740 --> 00:05:47.430
彼らは1000回繰り返した。

89
00:05:49.150 --> 00:05:53.820
すべての権利は、今では、この機能は標準的
なスケーリングされた知っている。

90
00:05:53.820 --> 00:05:59.798
おそらく、我々はそれをスケールアップしよ
うとすることができます。

91
00:05:59.798 --> 00:06:04.644
元のフィーチャに数値が乗算され、数値によ
ってシフトされました。

92
00:06:07.180 --> 00:06:11.130
我々が行う必要があるのは、撮影パラメータ
、およびスケーリングパラメータを見つける
ことです。

93
00:06:11.130 --> 00:06:15.982
しかし、どのように我々はそれを行うには、
それが本当に可能ですか?

94
00:06:15.982 --> 00:06:20.380
機能の一意の値を取り、それらを並べ替える
ことができます。

95
00:06:21.610 --> 00:06:26.660
そして、2つの連続した数字の差を印刷して
みましょう、

96
00:06:26.660 --> 00:06:29.836
この並べ替えられた配列。

97
00:06:29.836 --> 00:06:33.990
と見ると、価値観がずっと同じように見えま
す。

98
00:06:33.990 --> 00:06:38.366
この機能の2つの連続した一意の値間の距離

99
00:06:38.366 --> 00:06:40.700
元のデータでも同じでした。

100
00:06:40.700 --> 00:06:45.379
おそらく0.043
なんかではなかったのですが、

101
00:06:45.379 --> 00:06:50.943
それは誰が知っていた、それは9または11
または11.7 かもしれない

102
00:06:50.943 --> 00:06:55.620
でも、全ての組の間で同じだったので、

103
00:06:55.620 --> 00:07:03.100
それが1だったと仮定して、まあ、1は、自
然の選択のように見えます。

104
00:07:03.100 --> 00:07:08.626
この番号0.043
何かで我々の特徴を分割してみましょう、

105
00:07:08.626 --> 00:07:15.056
そして、我々はそれを行う場合、はい、我々
は違いが1にかなり近いとなることを参照し
てください、

106
00:07:15.056 --> 00:07:19.690
いくつかの数値エラーのためにのみ、それら
は1ではありません。

107
00:07:21.050 --> 00:07:28.228
我々はこの値によって我々の機能を分割する
ので、はい、これはあなたが得るものです。

108
00:07:28.228 --> 00:07:33.210
それで他に何が見える?

109
00:07:33.210 --> 00:07:39.430
我々は、各番号は、同じ値で終わることがわ
かります。

110
00:07:40.770 --> 00:07:44.956
各正の数値はこの種類の値で終了し、

111
00:07:44.956 --> 00:07:47.510
これでそれぞれ陰性、見てください。

112
00:07:47.510 --> 00:07:52.216
これは、この小数部の一部だったように見え
ます

113
00:07:52.216 --> 00:07:57.540
シフトパラメータは、ちょうどそれを減算し
てみましょう。

114
00:07:57.540 --> 00:08:02.620
実際には、実際にはそれを減算すると、デー
タは整数のように見えます。

115
00:08:02.620 --> 00:08:06.440
それは整数データだったように、再び数値エ
ラーのために、

116
00:08:06.440 --> 00:08:08.930
変な数字が見える

117
00:08:11.730 --> 00:08:17.070
数字を丸めて、それは我々が得るものです。

118
00:08:17.070 --> 00:08:22.036
これは、実際には最初の10行ではなく、全
体の機能です。

119
00:08:22.036 --> 00:08:27.550
じゃあ次は?

120
00:08:27.550 --> 00:08:28.940
ここまで何をした?

121
00:08:28.940 --> 00:08:31.800
我々は、スケーリングパラメータを、おそら
く我々は正しかったが見つかりました

122
00:08:31.800 --> 00:08:35.630
数字は整数になったので、それは良い兆候だ
。

123
00:08:37.306 --> 00:08:43.590
我々は右ではないかもしれない、誰が知って
いるので、スケーリングパラメータは10か
もしれない

124
00:08:43.590 --> 00:08:48.340
2または再度11およびまだ数は整数である
。

125
00:08:48.340 --> 00:08:51.910
しかし、1は良い試合のように見えます。

126
00:08:53.080 --> 00:08:55.770
ランダムではないと思う

127
00:08:57.490 --> 00:09:00.570
しかし、どのように我々はシフトパラメータ
を見つけることができますか?

128
00:09:00.570 --> 00:09:06.675
我々は唯一の小数部を見つけた、我々は他を
見つけることができます

129
00:09:06.675 --> 00:09:11.330
そして、我々は整数の部分を見つけることが
できる、私は意味ですか?

130
00:09:13.900 --> 00:09:18.810
これは難しい質問だここには数字がたくさん
ある

131
00:09:18.810 --> 00:09:21.910
おそらく仮説を作成することができます。

132
00:09:21.910 --> 00:09:27.168
何かあるかもしれないし、この何かのための
正規の価値観はそのようなもので、

133
00:09:27.168 --> 00:09:30.944
そして、我々はおそらくそれをスケーリング
することが、この番号でシフト。

134
00:09:30.944 --> 00:09:35.016
しかし、それは単なる近似ではなく、仮説で
あり、

135
00:09:35.016 --> 00:09:38.640
だから我々の旅は本当にここに終わるかもし
れない

136
00:09:38.640 --> 00:09:41.791
でも、本当にラッキーだったし、

137
00:09:41.791 --> 00:09:47.007
私はあなたにそれを表示しますので、あなた
の x8 を取る場合。

138
00:09:47.007 --> 00:09:52.716
私たちの特徴を意味し、印刷値のカウントは
、我々が表示されます、

139
00:09:52.716 --> 00:09:57.580
我々はこの番号11、17、18、何か。

140
00:09:59.800 --> 00:10:05.327
下にスクロールすると、これが表示されます
-1968、

141
00:10:05.327 --> 00:10:10.519
そして、それは間違いなく出生の年のように
見える、右?

142
00:10:10.519 --> 00:10:13.145
すぐに私は仮説を持って、

143
00:10:13.145 --> 00:10:18.770
これは、人が出生の彼の年を入力する必要が
ありますテキストボックスがあります。

144
00:10:20.090 --> 00:10:24.190
そして、ほとんどの人が本当に誕生の年を入
力しますが、

145
00:10:24.190 --> 00:10:26.020
1人はゼロに入った。

146
00:10:27.160 --> 00:10:31.020
またはシステムが自動的に入力 0,
何か間違ったことが起こったとき.

147
00:10:32.100 --> 00:10:35.021
とうわー、それはキーではありません。

148
00:10:35.021 --> 00:10:38.277
値がもともと0であると仮定すると、

149
00:10:38.277 --> 00:10:43.494
その後、シフトのパラメータは正確に906
8です、それを試してみましょう。

150
00:10:44.900 --> 00:10:49.280
私たちのデータに9068を追加し、値を参
照してみましょう。

151
00:10:49.280 --> 00:10:54.696
ここでも、値カウント関数を使用し、並べ替
えられた値を並べ替えます。

152
00:10:54.696 --> 00:11:00.156
これは、最小値であり、実際には、最小限の
0を参照してください、

153
00:11:00.156 --> 00:11:05.450
そして、全ての価値観がネガティブではなく
、本当にもっともらしいです。

154
00:11:06.560 --> 00:11:11.794
見てみましょう、999、それはおそらく人
々が入力するのが大好きです

155
00:11:11.794 --> 00:11:17.046
彼らは何か、またはこれは、1899を入力
するように求めている。

156
00:11:17.046 --> 00:11:21.660
それはこの教科書のデフォルト値かもしれな
い、それは何度も発生しました。

157
00:11:23.060 --> 00:11:25.700
それから変な値が見える

158
00:11:25.700 --> 00:11:27.820
人々はちょうどランダムにそれらを置く。

159
00:11:30.120 --> 00:11:33.649
そして、我々は日付を介して分布のいくつか
の種類を参照してください。

160
00:11:34.910 --> 00:11:39.225
それは1980のように、今住んでいる人々
のためにもっともらしいです。

161
00:11:41.062 --> 00:11:45.070
まあ多分1938、私はこのことについては
よく分からない、

162
00:11:45.070 --> 00:11:49.760
そしてもちろん、我々は将来からいくつかの
日を参照してください、しかし、

163
00:11:49.760 --> 00:11:53.310
確かに生まれた年のように見えますよね?

164
00:11:58.240 --> 00:12:02.150
さて、質問は、どのように競争のためにこの
情報を使用することができますか?

165
00:12:03.750 --> 00:12:05.847
線形モデルのためのよく再度、

166
00:12:05.847 --> 00:12:11.680
おそらく、年齢層、またはそのようなものの
ような新しい機能を作ることができます。

167
00:12:11.680 --> 00:12:14.190
しかし、この特定の競争では、

168
00:12:17.070 --> 00:12:20.550
これを使用して、この知識を使用する方法は
ありませんでした。

169
00:12:20.550 --> 00:12:22.264
でも、調べてみて本当に楽しかったです。

170
00:12:22.264 --> 00:12:27.415
私はあなたが例を好き願って、しかし、通常
は本当に難しいです

171
00:12:27.415 --> 00:12:32.880
出生匿名の特徴の年のように良識がある何で
も認識しなさい。

172
00:12:32.880 --> 00:12:36.190
私たちができる最善の機能の種類を認識する
ことです。

173
00:12:36.190 --> 00:12:40.000
それはカテゴリ、数値、テキスト、または何
か他のですか?

174
00:12:41.020 --> 00:12:45.120
先週、我々は、各データ型が異なる処理する
必要があります見た

175
00:12:45.120 --> 00:12:48.669
そして、より多くの治療法は、我々が使用し
たいモデルに依存します。

176
00:12:49.750 --> 00:12:54.857
そのため、より強力なモデルを作成するには
、どのようなデータを使用しているかを知る
必要があります。

177
00:12:54.857 --> 00:12:59.415
どんな特徴があるのか理解できないにもかか
わらず、

178
00:12:59.415 --> 00:13:03.830
少なくとも、データ内の変数の種類を検出す
る必要があります。

179
00:13:03.830 --> 00:13:07.450
この例を見てください、我々は意味のある企
業を持っていないが、

180
00:13:07.450 --> 00:13:10.970
まだ我々は特徴の種類が何であるかを推論す
ることができます。

181
00:13:10.970 --> 00:13:17.350
したがって、x1 は、テキストまたは物理
記録のように見える、x2 と x3
はバイナリである、

182
00:13:18.450 --> 00:13:23.510
x4 は数値、x5
はカテゴリか数値です。

183
00:13:23.510 --> 00:13:28.430
さらに、それは数字の場合、それはイベント
カレンダーのようなものかもしれない、

184
00:13:28.430 --> 00:13:30.220
値は整数です。

185
00:13:31.380 --> 00:13:34.920
この例のように、データセットの列数が小さ
い場合は、

186
00:13:34.920 --> 00:13:39.160
我々は、テーブルを持って、手動でタイプを
並べ替えることができます。

187
00:13:39.160 --> 00:13:42.870
しかし、データセットに1,000
の機能があるとしたらどうでしょうか。

188
00:13:44.050 --> 00:13:48.020
我々の探査を容易にするために非常に有用な
機能、

189
00:13:48.020 --> 00:13:53.310
パンダからの関数 d 型データフレーム内
の各列の型を推測します。

190
00:13:53.310 --> 00:13:58.164
通常は、すべての列を3つのカテゴリにグル
ープ化し、

191
00:13:58.164 --> 00:14:02.160
欠陥のある、整数、およびいわゆるオブジェ
クト型。

192
00:14:02.160 --> 00:14:06.130
機能に欠陥タイプが割り当てられている場合
は、dtype

193
00:14:06.130 --> 00:14:08.090
この機能は、ほとんどの場合、数値である可
能性があります。

194
00:14:09.450 --> 00:14:14.110
整数型の機能は、0または1でエンコードさ
れたバイナリのいずれかです。

195
00:14:14.110 --> 00:14:18.160
ラベルエンコーダーでエンコードされたイベ
ントカウンター、またはカテゴリもあります
。

196
00:14:19.500 --> 00:14:22.960
この関数は object
という名前の型を返すことがあります。

197
00:14:22.960 --> 00:14:27.160
そして、それは最も問題がある、それは何で
もすることができます

198
00:14:27.160 --> 00:14:31.150
いくつかのテキストで満たされた欠損値を持
つ不規則な数値機能であっても。

199
00:14:32.890 --> 00:14:37.580
あなたのデータでそれを試してみて、また、
パンダから完全な機能で非常によく似てチェ
ックアウト。

200
00:14:38.748 --> 00:14:44.660
オブジェクトタイプを扱うには、データを印
刷して、文字通りそれを見ておくと便利です
。

201
00:14:44.660 --> 00:14:48.468
値カウント機能を持つユニークな値をチェッ
クすると便利です。

202
00:14:48.468 --> 00:14:51.510
isnull 関数を使用して null
位置を確認することもできます。

203
00:14:52.860 --> 00:14:57.630
このレッスンでは、匿名の機能について2つ
のことを説明しました。

204
00:14:57.630 --> 00:14:58.580
我々は、時には見た

205
00:14:58.580 --> 00:15:03.820
これは、機能をデコードすることが可能です
, この機能は本当に意味を見つける.

206
00:15:04.960 --> 00:15:08.891
我々は、機能の意味を理解するかどうかは問
題ではない

207
00:15:08.891 --> 00:15:13.464
機能を事前処理するために、フィーチャタイ
プを推測する必要はありません。

208
00:15:13.464 --> 00:15:17.125
したがって、我々が持っているタイプには、
モデルクラスを選択します。

209
00:15:17.125 --> 00:15:20.555
次のビデオでは、我々はカラフルなプロット
の多くが表示されます、と

210
00:15:20.555 --> 00:15:25.135
視覚化、および探索的データ分析のためのそ
の他のツールについて説明します。

211
00:15:25.135 --> 00:15:35.135
音

