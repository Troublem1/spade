1
00:00:00.025 --> 00:00:05.829
音前のビデオで、我々は、検証を理解

2
00:00:05.829 --> 00:00:12.675
私たちは、目に見えないテストデータに最適
な実行されるモデルを選択するのに役立ちま
す。

3
00:00:12.675 --> 00:00:16.845
しかし、検証を使用するには、まず、指定さ
れたラベルでデータを分割する必要がありま
す。

4
00:00:16.845 --> 00:00:19.410
同調、および検証パーツ。

5
00:00:19.410 --> 00:00:23.130
このビデオでは、さまざまな検証方法につい
て説明します。

6
00:00:23.130 --> 00:00:25.140
と質問に答えます。

7
00:00:25.140 --> 00:00:27.304
どのように多くの分割を行う必要があります

8
00:00:27.304 --> 00:00:30.949
このような分割を実行する最も頻繁に行われ
るメソッドは何ですか。

9
00:00:30.949 --> 00:00:35.600
大まかに言えば、これらの検証戦略の主な違
いは、

10
00:00:35.600 --> 00:00:38.400
実行されている分割の数です。

11
00:00:38.400 --> 00:00:41.060
ここで私はそれらの3つについて説明します
。

12
00:00:41.060 --> 00:00:46.070
最初に提示され、2番目は、K
倍、および3番目のまま-1 アウトです。

13
00:00:46.070 --> 00:00:48.080
提示から始めましょう。

14
00:00:48.080 --> 00:00:52.910
データを2つの部分に分ける単純なデータ分
割だ

15
00:00:52.910 --> 00:00:55.880
トレーニングデータフレーム、および検証デ
ータフレーム。

16
00:00:55.880 --> 00:00:59.355
そして、ここで重要な注意点は、どの方法で
も、

17
00:00:59.355 --> 00:01:04.550
提示が含まれて、1つのサンプルのいずれか
の訓練や検証に行くことができます。

18
00:01:04.550 --> 00:01:09.260
なので電車と検証の間のサンプルが重ならず
、

19
00:01:09.260 --> 00:01:12.970
その場合は、検証を信頼できません。

20
00:01:12.970 --> 00:01:17.510
これは時々、我々はデータのサンプルを繰り
返している場合です。

21
00:01:17.510 --> 00:01:20.640
そして、もし我々が、我々はより良い予測を
取得します

22
00:01:20.640 --> 00:01:25.160
これらのサンプルと、より楽観的なすべての
推定全体。

23
00:01:25.160 --> 00:01:29.730
これは、これらの最適なパラメータを選択す
るから私たちを防ぐことができます参照して
くださいすることは簡単です

24
00:01:29.730 --> 00:01:30.266
私たちのモデル。

25
00:01:30.266 --> 00:01:34.816
たとえば、継手の上に一般的に悪いです。

26
00:01:34.816 --> 00:01:39.002
しかし、我々は、存在するサンプルを複製し
ている場合, と電車, と

27
00:01:39.002 --> 00:01:43.886
テストを同時に、フィードを介して、検証の
スコアに私たちを欺くことができます

28
00:01:43.886 --> 00:01:48.400
信念は、多分我々は正しい方向に移動してい
る。

29
00:01:48.400 --> 00:01:53.323
さて、それはなぜ列車との間のサンプルにつ
いての簡単なメモだった

30
00:01:53.323 --> 00:01:55.980
検証は重複してはいけません。

31
00:01:55.980 --> 00:01:57.460
提示に戻る。

32
00:01:57.460 --> 00:02:01.482
ここでは、トレーニングデータフレームにモ
デルを合わせて、

33
00:02:01.482 --> 00:02:04.010
検証データフレームの品質を評価します。

34
00:02:05.080 --> 00:02:09.460
この評価のスコアを使用して、我々は最高の
モデルを選択します。

35
00:02:09.460 --> 00:02:11.930
提出する準備ができたら、

36
00:02:11.930 --> 00:02:17.180
我々は、特定のラベルを使用してデータ上の
モデルを再訓練することができます。

37
00:02:17.180 --> 00:02:19.880
競争の中で提示を使用することを考える。

38
00:02:19.880 --> 00:02:23.420
これは通常、十分なデータがある場合に適し
ています。

39
00:02:23.420 --> 00:02:25.800
または我々は同様のスコアを取得する可能性
があります

40
00:02:25.800 --> 00:02:28.339
同じモデルは、我々は別の分割をしようとす
る場合。

41
00:02:29.520 --> 00:02:32.430
我々が提示されたものを理解して以来、素晴
らしい、

42
00:02:32.430 --> 00:02:36.616
のは、2番目の検証戦略は、K-倍と呼ばれ
る上に移動してみましょう。

43
00:02:36.616 --> 00:02:41.780
我々はにデータを分割するため、K-倍は、
繰り返し提示として表示することができます

44
00:02:41.780 --> 00:02:48.230
すべての部分を検証セットとして1回だけ使
用して、キーパーツを反復処理します。

45
00:02:48.230 --> 00:02:52.920
この手順の後、我々はこれらの
K-ひだ以上の平均スコア。

46
00:02:52.920 --> 00:02:57.730
ここでは、K-倍との違いを理解することが
重要です

47
00:02:57.730 --> 00:03:00.610
通常の提示または K 回のビット。

48
00:03:00.610 --> 00:03:05.947
それは彼らが K の異なる回りながらの後
に受け取る平均スコアすることが可能ですが
。

49
00:03:05.947 --> 00:03:09.607
この場合、一部のサンプルが無効になること
はありません。

50
00:03:09.607 --> 00:03:12.930
他の人が複数回することができますが。

51
00:03:12.930 --> 00:03:18.930
反対側では、K-倍のコアのアイデアは、我
々はすべてのサンプルを使用したいというこ
とです

52
00:03:18.930 --> 00:03:21.250
検証は1回だけです。

53
00:03:21.250 --> 00:03:25.470
この方法は、最小限のデータを使用する場合
に適しています。

54
00:03:25.470 --> 00:03:29.870
我々は、品質のいずれかを十分に大きな違い
を得ることができる、または

55
00:03:29.870 --> 00:03:33.180
折り目の間に異なる最適なパラメータ。

56
00:03:33.180 --> 00:03:35.365
偉大な、K-倍に対処して、

57
00:03:35.365 --> 00:03:39.740
このリリースでは、3番目の検証戦略に進む
ことができます。

58
00:03:39.740 --> 00:03:41.680
これは、ほっといて-
ワンアウトと呼ばれています。

59
00:03:41.680 --> 00:03:45.540
そして、基本的には Kfold
の特殊なケースです K

60
00:03:45.540 --> 00:03:48.850
は、データ内のサンプル数と等しくなります
。

61
00:03:48.850 --> 00:03:53.450
これは、データ内のすべてのサンプルを反復
処理することを意味します。

62
00:03:53.450 --> 00:03:58.560
usion がスロットに入ってくるたびに
1つのオブジェクトは、列車のサブセットで
あり、

63
00:03:58.560 --> 00:04:01.520
残りの1つのオブジェクトはテストサブセッ
トです。

64
00:04:01.520 --> 00:04:05.245
この方法は、データが少なすぎる場合に役立
ちます。

65
00:04:05.245 --> 00:04:07.152
同調するだけの十分なモデル。

66
00:04:07.152 --> 00:04:12.300
そこで、検証戦略。

67
00:04:12.300 --> 00:04:16.030
提示、K-フォールドと残す-ワンアウト。

68
00:04:16.030 --> 00:04:19.614
我々は通常、シャッフルデータに提示または
K-フォールドを使用してください。

69
00:04:19.614 --> 00:04:25.085
データをシャッフルすることで、訓練された
ランダムな検証分割を再現しようとしていま
す。

70
00:04:25.085 --> 00:04:29.497
しかし、時には、特に場合は、十分なサンプ
ルを持っていない

71
00:04:29.497 --> 00:04:32.950
クラスによっては、ランダム分割が失敗する
ことがあります。

72
00:04:32.950 --> 00:04:35.306
例については、考えてみましょう。

73
00:04:35.306 --> 00:04:41.274
我々は、バイナリの分類テストと8つのサン
プルを持つ小さなデータセットを持っていま
す。

74
00:04:41.274 --> 00:04:43.630
クラス0の4、クラス1の4。

75
00:04:43.630 --> 00:04:46.615
データを4つ折りに分割しましょう。

76
00:04:46.615 --> 00:04:53.810
完了しますが、通知は、常に同じ問題で0と
1を取得されていません。

77
00:04:53.810 --> 00:04:58.720
我々は検証のために2番目のフォールドを使
用する場合は、我々が取得します

78
00:04:58.720 --> 00:05:04.130
1つの半分の代わりに2番目の電車の中でタ
ーゲットの平均値。

79
00:05:04.130 --> 00:05:08.000
これにより、モデルの予測を大幅に変更でき
ます。

80
00:05:08.000 --> 00:05:12.676
この問題を処理するために必要なのは階層化
です。

81
00:05:12.676 --> 00:05:15.360
それはちょうど保証する方法です。

82
00:05:15.360 --> 00:05:19.710
我々は、異なる障害の上に同様のターゲット
分布を取得します。

83
00:05:19.710 --> 00:05:23.700
データを成層で4つの断層に分割すれば、

84
00:05:23.700 --> 00:05:28.310
各偽のターゲット値の平均は、1つの半分に
等しくなります。

85
00:05:29.340 --> 00:05:34.075
これは、この問題の重要性が高いことを推測
する方が簡単です, 最初の

86
00:05:34.075 --> 00:05:39.405
この例のように、アンバランスなデータセッ
トのための2番目の小さなデータセット。

87
00:05:39.405 --> 00:05:41.415
そして、バイナリの分類のために、それは可
能性があります

88
00:05:41.415 --> 00:05:46.500
ターゲットの平均が非常に0またはその逆に
非常に近い場合は、非常に1に近い。

89
00:05:46.500 --> 00:05:52.070
そして3番目に、クラスの膨大な量の
multiclass
分類タスクのために。

90
00:05:52.070 --> 00:05:54.770
適切な分類データセットについては、

91
00:05:54.770 --> 00:05:58.910
成層分割は、単純なシャッフル分割にかなり
似ています。

92
00:05:58.910 --> 00:06:00.600
つまり、ランダムに分割します。

93
00:06:01.610 --> 00:06:06.890
よくやった、このビデオでは、我々は別の検
証戦略を議論している

94
00:06:06.890 --> 00:06:09.360
それらの各1つを使用する理由。

95
00:06:09.360 --> 00:06:11.420
これを全部まとめてみましょう。

96
00:06:11.420 --> 00:06:15.400
我々は十分なデータを持っている場合、我々
は同様のスコアを取得する可能性が高いです
し、

97
00:06:15.400 --> 00:06:21.120
異なる分割のための最適なモデルのパラメー
タは、我々が提示して行くことができます。

98
00:06:21.120 --> 00:06:25.350
逆に、スコアと最適なパラメータが異なる場
合

99
00:06:25.350 --> 00:06:28.870
異なる分割は、我々は KFold
アプローチを選択することができます。

100
00:06:28.870 --> 00:06:34.383
そして、イベントは、我々はあまりにも少な
いデータの場合、我々は休暇を適用すること
ができます-1 アウト。

101
00:06:34.383 --> 00:06:40.205
あなたのためにこのビデオから2番目の大き
なテイクアウトは、成層する必要があります
。

102
00:06:40.205 --> 00:06:44.850
これは、検証をより安定させるのに役立ちま
す, 特に便利な

103
00:06:44.850 --> 00:06:48.760
小さくてアンバランスなデータセット。

104
00:06:48.760 --> 00:06:49.770
すごい。

105
00:06:49.770 --> 00:06:54.923
次のビデオでは、我々はそれのコアで検証を
理解していきます。

106
00:06:54.923 --> 00:07:01.646
音

107
00:07:01.646 --> 00:07:07.389
音楽

