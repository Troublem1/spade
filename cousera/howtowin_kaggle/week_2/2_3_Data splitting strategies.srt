1
00:00:03.730 --> 00:00:06.406
我々はすでに検証のための主要な戦略を知っ
ているので、

2
00:00:06.406 --> 00:00:10.240
より具体的な例に移ります。

3
00:00:10.240 --> 00:00:12.237
レッツは、我々は、時系列予測との競争を解
決している、すなわち、想像してみましょう

4
00:00:12.237 --> 00:00:20.695
我々は、彼らが来月に予定している店のため
の顧客の数を予測することです。

5
00:00:20.695 --> 00:00:24.675
ここではどのようにしてデータを列車と検証
に分けるべきでしょうか。

6
00:00:24.675 --> 00:00:27.275
基本的には2つの可能性があります。

7
00:00:27.275 --> 00:00:32.610
最初のデータフレームを持つ、我々は検証と
2番目のランダムな行を取ることができる、

8
00:00:32.610 --> 00:00:34.999
我々は、時間ベースの分割を行うことができ
ます

9
00:00:34.999 --> 00:00:41.120
列車としていくつかの日付の前にすべてを取
り、そこに検証として。

10
00:00:41.120 --> 00:00:44.400
次の2つのオプションを計画してみましょう
。

11
00:00:44.400 --> 00:00:49.725
今、あなたが生成する必要がある機能とあな
たが訓練する必要があるモデルを考えるとき
、

12
00:00:49.725 --> 00:00:52.575
どのように複雑なこの2つのケースですか?

13
00:00:52.575 --> 00:00:54.100
最初のブロックでは、

14
00:00:54.100 --> 00:00:59.475
我々はちょうど我々の予測を得るために、前
と次の値の間で解釈することができます。

15
00:00:59.475 --> 00:01:01.485
非常に簡単ですが、待ってください。

16
00:01:01.485 --> 00:01:05.990
本当に現実の世界の顧客の数についての将来
の情報がありますか?

17
00:01:05.990 --> 00:01:11.455
まあ、おそらくない。しかし、この検証は役
に立たないということですか?

18
00:01:11.455 --> 00:01:13.280
もう一度、それはありません。

19
00:01:13.280 --> 00:01:16.255
それが本当に意味することは、もし我々が作
る

20
00:01:16.255 --> 00:01:19.815
列車の検証は、列車/テストの分割とは異な
る分割、

21
00:01:19.815 --> 00:01:23.270
その後、我々は無駄なモデルを作成する予定
です。

22
00:01:23.270 --> 00:01:27.085
そして、ここでは、我々は信頼性の高い検証
を行うの主なルールになる。

23
00:01:27.085 --> 00:01:29.475
出来れば

24
00:01:29.475 --> 00:01:31.985
列車/テストスプリットを模倣するように検
証を設定し、

25
00:01:31.985 --> 00:01:35.150
しかし、それは少し後です。

26
00:01:35.150 --> 00:01:36.960
この例に戻りましょう。

27
00:01:36.960 --> 00:01:38.350
2番目の画像では、

28
00:01:38.350 --> 00:01:39.940
ほとんどのテストポイントでは、

29
00:01:39.940 --> 00:01:43.680
我々は、次の値も前のいずれかを持っていま
す。

30
00:01:43.680 --> 00:01:48.945
さて、我々は異なる機能に訓練を受けた別の
モデルのプールを持っていると想像してみま
しょう

31
00:01:48.945 --> 00:01:53.515
そして、検証の種類ごとに最適なモデルを選
択しました。

32
00:01:53.515 --> 00:01:56.723
さて、質問は、これらのモデルは異なります
か?

33
00:01:56.723 --> 00:01:59.510
そして、もし彼らが、どのように大幅に?

34
00:01:59.510 --> 00:02:04.530
まあ、それはあなたが後でいくつかのポイン
トが起こるかを予測したい場合は、確かです

35
00:02:04.530 --> 00:02:07.590
その後、以前のような機能を好むモデル

36
00:02:07.590 --> 00:02:11.095
次のターゲット値は、パフォーマンスが低下
します。

37
00:02:11.095 --> 00:02:12.975
これは、この場合に発生するため、

38
00:02:12.975 --> 00:02:16.650
我々は、テストデータのような観測を持って
いない。

39
00:02:16.650 --> 00:02:20.655
しかし、我々は、機能値のモデルを何かを与
えなければならない

40
00:02:20.655 --> 00:02:24.485
そして、それはおそらく、数字や欠落値では
ありません。

41
00:02:24.485 --> 00:02:28.125
どのくらいの経験は、モデルは、これらのタ
イプの状況で持っている?

42
00:02:28.125 --> 00:02:33.985
そうでもないです。モデルだけでは、品質が
苦しむことは期待されません。

43
00:02:33.985 --> 00:02:37.090
さて、2つ目のケースを思い出してみましょ
う。

44
00:02:37.090 --> 00:02:41.495
実際には、ここでは時間の傾向にもっと頼る
必要があります。

45
00:02:41.495 --> 00:02:43.385
など、特徴は、

46
00:02:43.385 --> 00:02:45.135
ここに必要なモデルは

47
00:02:45.135 --> 00:02:50.570
何ヶ月または数週間の最後のカップルの傾向
だったようなものですか?

48
00:02:50.570 --> 00:02:54.990
そのため、モデルが最適なモデルとして選択
されていることを示しています

49
00:02:54.990 --> 00:03:00.030
最初のタイプの検証は、2番目のタイプの検
証では不十分に実行されます。

50
00:03:00.030 --> 00:03:03.360
反対に、第2のタイプのための最もよいモデ
ル

51
00:03:03.360 --> 00:03:07.077
検証は、先に多くのポイントを予測するため
に訓練された

52
00:03:07.077 --> 00:03:10.635
また、隣接するターゲット値は使用されませ
ん。

53
00:03:10.635 --> 00:03:13.365
だから、この比較を締結するには、

54
00:03:13.365 --> 00:03:16.570
これらのモデルは確かに大幅に異なる

55
00:03:16.570 --> 00:03:22.900
1つのモデルのための最も有用な機能は別の
役に立たないという事実を含む。

56
00:03:22.900 --> 00:03:27.565
しかし、生成された機能は、ここで唯一の問
題ではありません。

57
00:03:27.565 --> 00:03:31.656
実際の列車/テストの分割は時間ベースであ
ることを考慮し、

58
00:03:31.656 --> 00:03:33.450
ここで質問です。

59
00:03:33.450 --> 00:03:39.150
時間ベースのパターンに注目しているフィー
チャを慎重に生成する場合は、

60
00:03:39.150 --> 00:03:43.680
我々は、ランダムベースの分割で信頼性の高
い検証を取得します。

61
00:03:43.680 --> 00:03:46.665
もう一度別の言葉でこれを言わせてください
。

62
00:03:46.665 --> 00:03:50.280
役に立つ機能を作成します。

63
00:03:50.280 --> 00:03:54.255
時間ベースの割り勘で、やたら割り勘ではダ
メですが、

64
00:03:54.255 --> 00:03:59.070
ランダム分割を使用してモデルを選択するの
が正しいでしょうか?

65
00:03:59.070 --> 00:04:00.565
厳しい質問ですね。

66
00:04:00.565 --> 00:04:03.410
ちょっと時間を割いて考えてみましょう。

67
00:04:03.410 --> 00:04:05.790
よしこれに答えよう

68
00:04:05.790 --> 00:04:08.710
ターゲットがリニアトレインに落下した場合
を考えてみましょう。

69
00:04:08.710 --> 00:04:11.401
最初のブロックでは、

70
00:04:11.401 --> 00:04:14.685
ランダムに選択された検証の正確なケースを
参照してください。

71
00:04:14.685 --> 00:04:20.320
2番目に、我々は前に考慮と同じ時間ベース
の分割を参照してください。

72
00:04:20.320 --> 00:04:22.675
まず、一般的には気づきましょう

73
00:04:22.675 --> 00:04:28.370
モデル予測は、列車データを使用して計算さ
れたターゲットの平均値に近くなります。

74
00:04:28.370 --> 00:04:29.815
最初のブロックでは

75
00:04:29.815 --> 00:04:36.375
検証ポイントがテストポイントと比較してこ
の平均値に近い場合は、

76
00:04:36.375 --> 00:04:40.195
テストよりも検証でより良いスコアが得られ
ます。

77
00:04:40.195 --> 00:04:41.790
しかし、2番目のケースでは、

78
00:04:41.790 --> 00:04:47.545
検証ポイントは、ターゲットの平均値からの
テストポイントとほぼ同じです。

79
00:04:47.545 --> 00:04:49.485
そして、2番目のケースでは、

80
00:04:49.485 --> 00:04:53.510
検証スコアは、テストのスコアに似ています
。

81
00:04:53.510 --> 00:04:56.512
私たちがちょうど見つけたので、素晴らしい
、

82
00:04:56.512 --> 00:04:58.820
不正な検証の場合は、

83
00:04:58.820 --> 00:05:05.925
機能だけでなく、値のターゲットは、スコア
の非現実的な推定につながることができます
。

84
00:05:05.925 --> 00:05:09.110
今、その例は、あなたがするかもしれないも
のとまったく似ていました

85
00:05:09.110 --> 00:05:12.420
リアル大会を解きながらの出会い。

86
00:05:12.420 --> 00:05:18.343
多くの大会は、すなわち、時間ベースの分割
を使用して: ロスマン店の販売競争、

87
00:05:18.343 --> 00:05:22.835
は、在庫の需要競争やその他のふしだらな女
。

88
00:05:22.835 --> 00:05:27.925
だから、すぐに我々だけで議論しているこの
貴重な例をまとめるには、

89
00:05:27.925 --> 00:05:31.560
異なる分割戦略が大幅に異なる場合がありま
す。

90
00:05:31.560 --> 00:05:34.949
すなわち: 生成された機能では、

91
00:05:34.949 --> 00:05:37.964
モデルがその機能に依存する方法では、

92
00:05:37.964 --> 00:05:40.260
そして、ある種の標的漏れで

93
00:05:40.260 --> 00:05:43.945
それは、スマートなアイデアを見つけること
ができることを意味

94
00:05:43.945 --> 00:05:48.496
特徴の生成と一貫して我々のモデルを改善す
るために、

95
00:05:48.496 --> 00:05:53.060
我々は絶対に主催者によって行われた列車/
テストの分割を識別するためにしたい

96
00:05:53.060 --> 00:05:57.010
コンクールも含めて、それを再現。

97
00:05:57.010 --> 00:06:01.145
今、これらの分割戦略と競争のほとんどを分
類してみましょう、

98
00:06:01.145 --> 00:06:04.055
そしてそれらのための例を論議しなさい。

99
00:06:04.055 --> 00:06:08.000
ほとんどの分割は、3つのカテゴリに結合す
ることができます: ランダム分割、

100
00:06:08.000 --> 00:06:12.910
時間ベースの分割と id ベースの分割。

101
00:06:12.910 --> 00:06:17.055
最も基本的な1つ、ランダムな分割から始め
ましょう。

102
00:06:17.055 --> 00:06:20.515
始めましょう、最も一般的な作り方

103
00:06:20.515 --> 00:06:24.645
列車/テスト分割は、データを行ごとにラン
ダムに分割することです。

104
00:06:24.645 --> 00:06:28.910
これは通常、行が互いに独立していることを
意味します。

105
00:06:28.910 --> 00:06:34.075
たとえば、クライアントが単独で完済するか
どうかを予測するテストがあります。

106
00:06:34.075 --> 00:06:36.420
各行は人を表し、

107
00:06:36.420 --> 00:06:40.615
そして、これらの行は、互いにかなり独立し
ています。

108
00:06:40.615 --> 00:06:44.790
さて、多少の依存関係があるということを考
えてみましょう、例えば、

109
00:06:44.790 --> 00:06:49.655
家族や同じ会社で働いている人の中で。

110
00:06:49.655 --> 00:06:52.050
おそらく夫が信用を払えれば、

111
00:06:52.050 --> 00:06:54.130
彼の妻もそれを行うことができます。

112
00:06:54.130 --> 00:06:56.295
それはある不運によって意味する、

113
00:06:56.295 --> 00:07:00.750
夫は、電車のデータで、彼の妻は、テストデ
ータに提示されますが存在します。

114
00:07:00.750 --> 00:07:05.770
我々は、おそらくこれを探索し、その場合の
ための特別な機能を考案することができます
。

115
00:07:05.770 --> 00:07:07.765
このような可能性については、

116
00:07:07.765 --> 00:07:11.550
そして、そのような機能を実現することは本
当に面白いです。

117
00:07:11.550 --> 00:07:14.910
この場合、他の私はここで言及するほか、

118
00:07:14.910 --> 00:07:18.105
私たちのコースの次のレッスンで来る。

119
00:07:18.105 --> 00:07:21.720
だからもう一度、ランダムに分割された。

120
00:07:21.720 --> 00:07:24.100
2番目の方法は、時間ベースの分割です。

121
00:07:24.100 --> 00:07:29.900
我々はすでにこのビデオの冒頭に分割のユニ
ットの例を議論した。

122
00:07:29.900 --> 00:07:35.850
その場合、我々は一般的にトレーニングデー
タとして、特定の日付の前にすべてを持って
いる

123
00:07:35.850 --> 00:07:38.720
そしてテストデータとして日付の後の評価。

124
00:07:38.720 --> 00:07:42.410
これは特徴の生成に特別なアプローチを使用
する信号である場合もある

125
00:07:42.410 --> 00:07:46.470
特に、ターゲットに基づいて便利な機能を作
成します。

126
00:07:46.470 --> 00:07:49.230
例えば、我々は数を予測するためにされてい
る場合

127
00:07:49.230 --> 00:07:52.290
来週の毎日のお店のお客様は、

128
00:07:52.290 --> 00:07:54.315
私たちのようなものを思い付いたことができ
ます

129
00:07:54.315 --> 00:07:57.675
前週の同日の顧客数は、

130
00:07:57.675 --> 00:08:02.470
または過去1ヶ月間の顧客の平均数。

131
00:08:02.470 --> 00:08:04.135
私が前に述べたように、

132
00:08:04.135 --> 00:08:06.405
この分割は十分に広まっている。

133
00:08:06.405 --> 00:08:07.696
それはで使用された

134
00:08:07.696 --> 00:08:13.140
ロスマン店の販売競争とは、株式のふしだら
在庫需要競争では、

135
00:08:13.140 --> 00:08:15.480
そして、他の大会で。

136
00:08:15.480 --> 00:08:22.194
時間ベースの分割の検証の特殊なケースは、
移動ウィンドウの検証です。

137
00:08:22.194 --> 00:08:23.780
前の例では、

138
00:08:23.780 --> 00:08:27.710
我々は、列車と検証を分割する日付を移動す
ることができます。

139
00:08:27.710 --> 00:08:32.180
検証セットとして週後に順次使用すると、

140
00:08:32.180 --> 00:08:34.865
ちょうどこの写真のように。

141
00:08:34.865 --> 00:08:38.240
今、ランダムと時間ベースの分割に対処して
、

142
00:08:38.240 --> 00:08:41.663
ID ベースの分割について説明します。

143
00:08:41.663 --> 00:08:44.240
ID は、ユーザーの一意の識別子をするこ
とができます

144
00:08:44.240 --> 00:08:46.315
ショップ、またはその他のエンティティ。

145
00:08:46.315 --> 00:08:49.960
たとえば、タスクを解決する必要があること
を想像してみましょう。

146
00:08:49.960 --> 00:08:54.055
完全に新しいユーザーのための音楽の推奨事
項の。

147
00:08:54.055 --> 00:08:59.045
つまり、我々は列車とテストのユーザーの異
なるセットを持っています。

148
00:08:59.045 --> 00:09:04.280
もしそうなら、我々はおそらく結論を、ユー
ザーの歴史に基づいて機能を作ることができ
ます

149
00:09:04.280 --> 00:09:08.265
たとえば、ユーザーが先週聴いた曲の数は、

150
00:09:08.265 --> 00:09:11.360
完全に新しいユーザーのために役立つことは
ありません。

151
00:09:11.360 --> 00:09:13.885
ID ベースの分割の例として、

152
00:09:13.885 --> 00:09:18.660
私は価格競争にキャタピラーについてのビッ
トをお伝えしたいと思います。

153
00:09:18.660 --> 00:09:26.135
その競争では、列車/テストの分割は、いく
つかのカテゴリ id、すなわち、チューブ
id で行われた。

154
00:09:26.135 --> 00:09:30.646
我々は ID ベースの分割を採用する必要
がある場合、興味深いケースがあります。

155
00:09:30.646 --> 00:09:32.865
しかし、IDs
は私たちから隠されている。

156
00:09:32.865 --> 00:09:38.630
ここでは、隠された ID ベースの分割と
の競争の2つの例を言及したい。

157
00:09:38.630 --> 00:09:44.765
これらは、インテルと MumbaiODT
子宮頸がんスクリーニングコンテストが含ま
れています

158
00:09:44.765 --> 00:09:49.385
と自然保護漁業監視競争。

159
00:09:49.385 --> 00:09:51.025
最初のコンクールでは、

160
00:09:51.025 --> 00:09:54.050
我々は3つのクラスに患者を分類しなければ
ならなかった

161
00:09:54.050 --> 00:09:55.400
そして、患者ごとに、

162
00:09:55.400 --> 00:09:57.450
私たちはいくつかの写真があった。

163
00:09:57.450 --> 00:10:02.240
確かに、1人の患者の写真は同じクラスに属
しています。

164
00:10:02.240 --> 00:10:07.340
繰り返しになりますが、電車とテストの患者
のセットが重なっていませんでした。

165
00:10:07.340 --> 00:10:11.480
そして、我々はまた、訓練規則の分割でこれ
らを確保する必要があります。

166
00:10:11.480 --> 00:10:17.690
別の例として、自然保護漁業監視競争では、

167
00:10:17.690 --> 00:10:21.125
いくつかの異なる漁船から魚の写真があった
。

168
00:10:21.125 --> 00:10:25.590
繰り返しになりますが、漁船と電車とテスト
が重なっていませんでした。

169
00:10:25.590 --> 00:10:31.410
あなたがリスクを無視し、ランダムベースの
分割を行う場合ので、1つは簡単に
overfit 可能性があります。

170
00:10:31.410 --> 00:10:34.130
id が指定されていないため、

171
00:10:34.130 --> 00:10:37.815
競合他社は自分でこれらの id
を導出しなければならなかった。

172
00:10:37.815 --> 00:10:39.875
これらの両方の大会では、

173
00:10:39.875 --> 00:10:43.145
これは、画像をクラスタリングすることによ
って行うことができる。

174
00:10:43.145 --> 00:10:48.640
最も簡単なケースは、写真が次々と撮影され
たときだった

175
00:10:48.640 --> 00:10:51.320
ので、画像は非常に似ていた。

176
00:10:51.320 --> 00:10:56.715
このようなクラスタリングの詳細については
、これらの大会のカーネルで見つけることが
できます。

177
00:10:56.715 --> 00:11:00.260
さて、これらの2つの主要なスタンドアロン
の方法では、

178
00:11:00.260 --> 00:11:03.850
また、彼らは時々結合されることがあります
知っている必要があります。

179
00:11:03.850 --> 00:11:07.685
たとえば、お店で売り上げを予測するタスク
がある場合、

180
00:11:07.685 --> 00:11:11.615
個別にお店ごとにデートで割り勘を選べます
し、

181
00:11:11.615 --> 00:11:15.995
代わりに、データ内のすべてのショップに1
つの日付を使用します。

182
00:11:15.995 --> 00:11:20.360
または別の例では、複数のユーザーからの検
索クエリがある場合は、

183
00:11:20.360 --> 00:11:22.490
いくつかの検索エンジンを使用している

184
00:11:22.490 --> 00:11:26.874
我々は、ユーザー id と検索エンジンの
id の組み合わせでデータを分割すること
ができます。

185
00:11:26.874 --> 00:11:32.100
結合分割を含むコンペティションの例として
は、

186
00:11:32.100 --> 00:11:36.080
デロイトによる西オーストラリア州のレンタ
ル価格競争

187
00:11:36.080 --> 00:11:41.390
とデータ科学ゲーム2017の彼らの資格段
階。

188
00:11:41.390 --> 00:11:43.060
最初のコンクールでは、

189
00:11:43.060 --> 00:11:45.760
列車/テストは、単一の日付で分割された,

190
00:11:45.760 --> 00:11:52.145
しかし、パブリック/プライベートスプリッ
トは、異なる地理的領域の異なる日付によっ
て行われた。

191
00:11:52.145 --> 00:11:53.720
第2回大会では、

192
00:11:53.720 --> 00:11:56.195
参加者は予測する必要があったかどうか

193
00:11:56.195 --> 00:11:59.520
オンライン音楽サービスのユーザーは、曲を
聴くことができます。

194
00:11:59.520 --> 00:12:03.310
電車/テストの分割は、次の方法で行われた
。

195
00:12:03.310 --> 00:12:08.860
ユーザーごとに、最後に聴いた曲がテストセ
ットに置かれ、

196
00:12:08.860 --> 00:12:12.890
他のすべての曲は、列車のセットに配置され
ている間。

197
00:12:12.890 --> 00:12:19.105
いい。これらは大会で採用された主な分裂の
作戦だった。

198
00:12:19.105 --> 00:12:23.860
繰り返しますが、私はあなたがこのレッスン
から奪うようにしたい主なアイデアは、

199
00:12:23.860 --> 00:12:29.385
あなたの検証は、常に主催者によって行わ列
車/テストスプリットを模倣する必要があり
ます。

200
00:12:29.385 --> 00:12:31.645
それは何か非些細なことができます。

201
00:12:31.645 --> 00:12:36.580
たとえば、ホーム・デポ製品検索の関連性コ
ンペティションでは、

202
00:12:36.580 --> 00:12:40.700
参加者は、検索の関連性を推定するよう求め
られた。

203
00:12:40.700 --> 00:12:47.215
一般に、データは、検索用語とそれらの用語
の検索結果から成りました、

204
00:12:47.215 --> 00:12:52.120
しかし、テストセットは完全に新しい検索用
語が含まれます。

205
00:12:52.120 --> 00:12:59.320
そのため、ランダム分割または検索用語ベー
スの分割を使用して検証を行うことはできま
せんでした。

206
00:12:59.320 --> 00:13:02.370
最初の分割は、より複雑なモデルを支持,

207
00:13:02.370 --> 00:13:08.215
これは、逆に、underfitting 
に2番目の分割中にオーバーフィット回避に
つながった。

208
00:13:08.215 --> 00:13:11.350
したがって、最適なモデルを選択するために
は、

209
00:13:11.350 --> 00:13:17.470
これは、列車/テストスプリットから新しい
検索用語の比率を模倣することが重要でした
。

210
00:13:17.470 --> 00:13:19.565
すごい。そうなんです。

211
00:13:19.565 --> 00:13:24.468
私達はちょうど競争で使用される主要なデー
タ分割の作戦を示した。

212
00:13:24.468 --> 00:13:27.015
ランダム分割、時間ベース分割、

213
00:13:27.015 --> 00:13:30.585
ID ベースの分割とその組み合わせ。

214
00:13:30.585 --> 00:13:33.655
これは、我々は信頼性の高い検証を構築する
のに役立ちます

215
00:13:33.655 --> 00:13:36.550
特徴の生成についての有用な決定をしなさい
、

216
00:13:36.550 --> 00:13:41.625
最後に、テストデータに最も適したモデルを
選択します。

217
00:13:41.625 --> 00:13:43.400
このビデオの主なポイントとして、

218
00:13:43.400 --> 00:13:48.545
信頼性の高い検証を行う一般的なルールを覚
えておいてください。

219
00:13:48.545 --> 00:13:54.620
コンペティションの列車/テストスプリット
を模倣するように検証を設定します。

